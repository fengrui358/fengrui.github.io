# Timer 的性能优势


假如有这样一个场景，1 个 100 万用户同时在线的系统，假设有一个 Session 管理器来管理它们的存亡，每个用户的 Session 有效时间假设 5 分钟，通常一个最简单的做法是在一个 Session 管理器中启动一个 Thread 去定时校验每个 Session 是否到达有效期截止时间，将到期的 Session 清理掉，而这个需求就导致存放 Session 的字典必须支持并发。而另一种做法就是在每个 Session 对象的内部去启动一个 Timer 让 Timer 在指定时间后去校验自身是否到期，若到期则发出事件通知让管理器去做清理工作。

测试结果，使用 Thread 的方式 CPU 一直保持在 4% 左右，而使用 Timer 的方式 CPU 保持在 0，内存比 Thread 方式多用 100 多 mb。按照存储比 CPU 便宜的标准，即使是内存消耗感觉也是第二种方式会更好一些。

>2017 年 3 月 9 日补充：这篇文章过时了，今天读到篇文章，原来可以用一种叫环形队列的数据结构来处理这种大量的超时任务。参见：<http://mp.weixin.qq.com/s/mvFwjgxliwx808Hn_9ruEA>。

