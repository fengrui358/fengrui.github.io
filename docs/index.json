[{"categories":null,"content":"  free 笔记 是一个简洁、优雅且高效的 Hugo 博客网站。 路的尽头是风景free 笔记 \" 路的尽头是风景 ","date":"2019-08-04","objectID":"/about/:0:0","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":null,"content":"介绍  笔记主人：奉锐  坐标：成都  邮箱 qjdev@qq.com  微信 feng_rui  主要领域为前端技术，后端技术略懂，欢迎探讨研究。 ","date":"2019-08-04","objectID":"/about/:0:1","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":["dotnet"],"content":"Xamarin Android 项目在编译时会从 google 的服务器下载缺失的 m2repository 相关文件，虽然不明白这是干什么的，但是情况就是 Andorid SDK Manager 不会去下载这个东西，然后在 VS 里编译某些项目时会去下载某些版本的 m2repository 文件。 由于墙的关系这个肯定是下载不下来的，所以只能通过迅雷穿墙下载，然后拷贝到指定的目录，这个目录就是它报错的提示里的一个文件夹，路径类似于：C:\\Users\\Administrator\\AppData\\Local\\Xamarin\\zips，下载的路径可以从国内的镜像网站找，也可以根据报错提示从 google 的网站下，官方的下载路径类似于：https://dl-ssl.google.com/android/repository/android_m2repository_r10.zip 下载完毕后需要放入上面的指定文件夹，还要修改文件的名字，对应关系如下（截止至 23.3.0 版）： Android： 23.3.0 —— android_m2repository_r29.zip —————– 2A3A8A6D6826EF6CC653030E7D695C41.zip 23.2.1 —— android_m2repository_r28.zip —————– 17BE247580748F1EDB72E9F374AA0223.zip 23.1.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.0.1.3 —— android_m2repository_r22.zip —————– 96659D653BDE0FAEDB818170891F2BB0.zip 23.0.1.1 —— android_m2repository_r20.zip —————– 650E58DF02DB1A832386FA4A2DE46B1A.zip 22.2.1 —— android_m2repository_r16.zip —————– 0595E577D19D31708195A83087881EE6.zip 22.2.0 —— android_m2repository_r15.zip —————– F9D66CC0ADC0C3787F4DAE6D494E6BC7.zip 22.1.1.1 —— android_m2repository_r14.zip —————– AB24E1C26FC70B44683752D37075AC06.zip 22.0.0 —— android_m2repository_r12.zip —————– 806FD8EEF161DCEA979C128F27BE5867.zip 21.0.3 —— android_m2repository_r10.zip —————– 1FD832DCC1792D8ACA07FAC3259FC5A9.zip 19.0.1 —— support_r19.0.1.zip —————– CED55A39D1283BB9DC217CAE987067E0.zip Google： 8.4 —— google_m2repository_r24.zip —————– CAA441D76F04E0D57C4110F8A00CDA7A.zip 以上有缺失和错误的欢迎补充，给出一个完整包的下载地址： http://pan.baidu.com/s/1boOwuZ1 ","date":"2016-06-22","objectID":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/:0:0","tags":["dotnet","async"],"title":"Timer 的性能优势","uri":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/"},{"categories":["dotnet"],"content":"Xamarin Android 项目在编译时会从 google 的服务器下载缺失的 m2repository 相关文件，虽然不明白这是干什么的，但是情况就是 Andorid SDK Manager 不会去下载这个东西，然后在 VS 里编译某些项目时会去下载某些版本的 m2repository 文件。 由于墙的关系这个肯定是下载不下来的，所以只能通过迅雷穿墙下载，然后拷贝到指定的目录，这个目录就是它报错的提示里的一个文件夹，路径类似于：C:\\Users\\Administrator\\AppData\\Local\\Xamarin\\zips，下载的路径可以从国内的镜像网站找，也可以根据报错提示从 google 的网站下，官方的下载路径类似于：https://dl-ssl.google.com/android/repository/android_m2repository_r10.zip 下载完毕后需要放入上面的指定文件夹，还要修改文件的名字，对应关系如下（截止至 23.3.0 版）： Android： 23.3.0 —— android_m2repository_r29.zip —————– 2A3A8A6D6826EF6CC653030E7D695C41.zip 23.2.1 —— android_m2repository_r28.zip —————– 17BE247580748F1EDB72E9F374AA0223.zip 23.1.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.0.1.3 —— android_m2repository_r22.zip —————– 96659D653BDE0FAEDB818170891F2BB0.zip 23.0.1.1 —— android_m2repository_r20.zip —————– 650E58DF02DB1A832386FA4A2DE46B1A.zip 22.2.1 —— android_m2repository_r16.zip —————– 0595E577D19D31708195A83087881EE6.zip 22.2.0 —— android_m2repository_r15.zip —————– F9D66CC0ADC0C3787F4DAE6D494E6BC7.zip 22.1.1.1 —— android_m2repository_r14.zip —————– AB24E1C26FC70B44683752D37075AC06.zip 22.0.0 —— android_m2repository_r12.zip —————– 806FD8EEF161DCEA979C128F27BE5867.zip 21.0.3 —— android_m2repository_r10.zip —————– 1FD832DCC1792D8ACA07FAC3259FC5A9.zip 19.0.1 —— support_r19.0.1.zip —————– CED55A39D1283BB9DC217CAE987067E0.zip Google： 8.4 —— google_m2repository_r24.zip —————– CAA441D76F04E0D57C4110F8A00CDA7A.zip 以上有缺失和错误的欢迎补充，给出一个完整包的下载地址： http://pan.baidu.com/s/1boOwuZ1 ","date":"2016-05-16","objectID":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["xamarin"],"title":"解决 Xamarin Android 墙的问题","uri":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["dotnet"],"content":"在 .Net 4 中，Task.Factory.StartNew是启动一个新Task的首选方法。它有很多重载方法，使它在具体使用当中可以非常灵活，通过设置可选参数，可以传递任意状态，取消任务继续执行，甚至控制任务的调度行为。所有这些能力也带来了复杂性的提升，你必须知道何时应该使用何种重载方法，提供哪种调度方式等等。并且Task.Factory.StartNew这种写法也不够简洁明快，至少对它使用的主要场景不够快，一般它使用的主要场景只是将一个工作任务丢给一个后台线程执行而已。 于是，在 .NET Framework 4.5 开发者预览版 中，微软引进了新的Task.Run方法。新方法不是为了替代旧的Task.Factory.StartNew方法，只是提供了一种使用Task.Factory.StartNew方法的更简洁的形式，而不需要去指定那一系列参数。这是一个捷径，事实上，Task.Run的内部实现逻辑跟Task.Factory.StartNew一样，只是传递了一些默认参数。比如当你使用Task.Run： Task.Run(someAction); 实际上等价于： Task.Factory.StartNew(someAction, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 使用这些默认参数，Task.Run就能用于大多数情况——只是将任务简单的交给后台线程池去执行（这也是使用TaskScheduler.Default参数的目标）。这也并不意味着Task.Factory.StartNew方法就不必再使用了，它仍然有很多重要的用处。你可以通过控制TaskCreationOptions参数来控制任务的行为，你也可以通过控制TaskScheduler来控制任务应该如何排队如何运行，你也可以使用重载方法中的接受对象状态那个参数，对于一些性能敏感的代码，它可以用于避免闭包以及相应的资源分配。不过对于上面那个简单的例子，Task.Run是最友好。 Task.Run提供了八种重载方式，用于提供下面这几种组合情况： 普通任务（Task）和带返回值任务（Task\u003cTResult\u003e） 可取消任务（Cancelable）和不可取消任务（non-cancelabl） 同步委托（Synchronous）和异步委托（Asynchronous） 前两个很明显，对于第一点如果是用的Task做返回值的重载方法，那么该任务就没有返回值，如果是用的Task\u003cTResult\u003e做返回值的重载方法，那么该任务就有一个类型为TResult的返回值。对于第二点，也有接受CancellationToken参数的重载，可以在任务开始之前执行取消操作，然后并行任务（Task Parallel Library——TPL）就可以自然的过度到取消状态。 第三点要更有趣一些，它直接关系到 Visual studio 11 中的 C#和 Visual Basic 的异步语言支持。我们先使用Task.Factory.StartNew来展示下这个问题，如果有下面一段代码： var t = Task.Factory.StartNew(() =\u003e { Task inner = Task.Factory.StartNew(() =\u003e {}); return inner; }); 这里t的类型会被推断为Task\u003cTask\u003e，因为此处任务的委托类型是Func\u003cTResult\u003e，所以这里TResult的类型就是Task，于是StartNew方法就返回Task\u003cTask\u003e，类似的，我可以改变成下面这种写法： var t = Task.Factory.StartNew(() =\u003e { Task\u003cint\u003e inner = Task.Factory.StartNew(() =\u003e 42)); return inner; }); 此处的t的类型自然是Task\u003cTask\u003cint\u003e\u003e，任务的委托类型还是Func\u003cTResult\u003e，TResult的类型就是Task\u003cint\u003e，StartNew方法就返回Task\u003cTask\u003cint\u003e\u003e。这有什么关系呢？考虑下如果我们现在使用下面这种写法： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }); 这里使用了async关键词，编译器会将这个委托映射成Func\u003cTask\u003cint\u003e\u003e，调用这个委托最终会返回Task\u003cint\u003e。因为这个这个委托是Func\u003cTask\u003cint\u003e\u003e，TResult的类型就是Task\u003cint\u003e，所以最后t的类型应该是Task\u003cTask\u003cint\u003e\u003e，而不是Task\u003cint\u003e。 为了应对这几种情况，在 .Net 4 中引入了Unwrap方法。Unwrap方法有两种重载形式，均是扩展方法的形式，一种是针对类型Task\u003cTask\u003e，另一种是针对\u003cTask\u003cTResult\u003e\u003e。微软只所以要把这个方法命名为解包（Unwrap），是因为这个方法可以返回任务的实际结果。对Task\u003cTask\u003e调用Unwrap方法可以返回一个新的Task（就像内部任务的一个代理一样）代表它的内部任务。相似的，对Task\u003cTask\u003cTResult\u003e\u003e调用Unwrap返回一个新的Task\u003cTResult\u003e代表它的内部任务。但是，如果外部任务失败了或者取消了，就不会有内部任务了，因为没有任务运行完成，所以代理任务也就变成了外部任务的状态。回到前面的例子，如果想让t代表内部任务的返回值（在这个例子中，这个值是 42），那么应该像下面这样写： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }).Unwrap(); 现在，变量t的类型是Task\u003cint\u003e，代表异步调用的结果。 现在回到Task.Run，因为微软想让开发者尽可能的使用这个方法来启用后台任务，并且可以配合async/await使用，所以微软决定在Task.Run方法中内建unwrapping的功能。这也是上面第三点所指的内容，Task.Run的重载方法中有可以接受Action（没有返回值的任务）的，有接受Func\u003cTResult\u003e（返回TResult的任务）的，有接受Func\u003cTask\u003e（返回一个异步任务的任务）的，还有接受Func\u003cTask\u003cTResult\u003e\u003e（返回一个带TResult类型返回值的异步任务的任务）的。总的来说，Task.Run方法提供了上面Task.Factory.StartNew方法相同的unwrapping操作。于是，我们可以这样写： var t = Task.Run(async delegate { await Task.Delay(1000); return 42; }); t的类型是Task\u003cint\u003e，此处Task.Run执行的重载方法等价于： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 如前所述，这是一个快捷方式。 上面讲的全部类容都意味着你可以使用Task.Run调用标准的lambdas/anonymous方法或是异步lambdas/anonymous方法，最后总会按你所期望的行为运行。如果我们想让任务在后台运行并且想等待它的结果，那么可以像下面这样写： int result = await Task.Run(async () =\u003e { await Task.Delay(1000); return 42; }); 此处变量result的类型正是你所期望的int，并且在该任务被调用大约 1 秒钟后，变量result的值被设置为 42。 有趣的是，新的await关键字被认为是等价于Unwrap方法的一种新语法形式。于是，如果我们回到上面那个Task.Factory.StartNew例子，我们可以先用Unwrap重写上面那个代码片段： int result = await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 或者，可以使用第二个await替换Unwrap： int result = await await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 这里的await await虽然看着别扭，但是并没有问题。Task.Factory.StartNew方法返回一个Task\u003cTask\u003cint\u003e\u003e，对Task\u003cTa","date":"2016-03-05","objectID":"/task.run-vs-task.factory.startnew/:0:0","tags":["dotnet","async","translation"],"title":"Task.Run Vs Task.Factory.StartNew","uri":"/task.run-vs-task.factory.startnew/"},{"categories":["dotnet"],"content":"安装 使用标准安装流程(JDK1.6 -\u003e Android SDK -\u003e NDK -\u003e Xamarin Studio -\u003e Xamarin Visual Studio) Android SDK Manager 更改源，可时刻保持最新，一个镜像源地址：mirrors.neusoft.edu.cn；ubuntu.buct.cn；Port: 80，Android SDK的目录结构介绍，Android的一些相关资源 http://ubuntu.buct.edu.cn/android/repository/。 Windows 端破解流程两步：替换 IDE 的 Dll，两个位置，一个是 VS 的 Common 下，一个 Xamarin Studio 的 bin 下；替换对应版本的 mandroid.exe 和 mtouch.exe Mac 端破解流程，Mac 端只负责 iOS 相关的东西，不考虑在 Mac 端开发 Android，首先要安装的东西包括：MonoFramework-MDK-3.12.1.3.macos10.xamarin.x86.pkg； monotouch-8.8.2.4.pkg ；XamarinStudio-5.8.2.7-0.dmg；(版本号注意要匹配，现在这一系列的版本号匹配的是 Windows 端的 3.9.525) 装完之后主要要替换三个东西：/Developer/MonoTouch/usr/bin/mtouch-64； Mtouch-64 替换完毕后需要在终端执行命令：chmod a+x /Developer/MonoTouch/usr/bin/mtouch-64 然后替换/Applications/Xamarin Studio.app/Contents/Resources/lib/monodevelop/AddIns/Xamarin.Ide/Xamarin.Components.Ide.dll 最后替换 /Applications/Xamarin.iOS Build Host.app/Contents/MonoBundle/Xamarin.Components.Ide.dll ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"模拟器 可以不使用 android 的标准模拟器，使用 Xamarin Android Player，据说性能要好一些，但是版权原因还没测试。 如果使用标准模拟器，可配置硬件加速 首先，你的 CPU 必须支持 Intel 虚拟化技术，如果支持进 BIOS 打开 使用 Android SDK 下载对应的 x86架构的系统镜像 上Intel官网下载最新的HAXM虚拟引擎，或者直接用SDK下载 下载后需要手动安装，如果双击安装无效，使用管理员权限运行 CMD，执行安装目录下的那个 Bat 文件；如果提示不支持 Intel 虚拟化技术，但是我们确认是打开了的，可能是因为操作系统装了 Hyper 的原因，卸载 Hyper 重启再试一次 进 AVD 创建基于 X86 的虚拟机 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"安卓引用的文件结构 文件夹 作用 Components 登录 Xamarin 账户可下载它官方提供的一些组件直接使用 Assets 存放字体、本地数据库、配置文件等一系列本地资源 Properties 除了常规的程序集版本号等信息，含包括 Android 程序的权限描述文件AndroidManifest.xml Resources 包好 Strings，images，layout 等资源的文件夹，注意程序的视图界面也在该文件夹下，还包括一个 AboutResources.txt 资源描述文件 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"安卓应用的逻辑结构 安卓应用跟传统应用不一样，没有单点入口，应用和安卓操作系统紧密联系，操作系统可以随时将应用进程载入内存激活应用。因此应用中有一个 Activity 的概念，一个应用由很多 Activity 组成。 Activity 的特性： Label：告诉操作系统这个类属于哪个程序，它会去 AndroidManifest.xml 里去匹配。 MainLauncher：告诉操作系统打开程序后激活哪个页面。 Activity的生命周期：created, started and paused, resumed and destroyed, and so on。 通过重写基类的生命周期方法来实现自己的逻辑，如：OnCreate（应用程序被装载到内存中时调一次），OnResume（设备执行别的任务后，该 Activity 返回设备界面时触发），OnPause（设备将执行其他任务，该 Activity 离开设备界面时触发） ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"Xamarin.Forms相关 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"简介 可以跨平台的构建用户交互相关的东西，简而言之就是写一套代码三个平台通用，在此基础上也能够结合各平台特有的 Xamarin 本地代码混合一起。 Forms 除了跨平台的好处意外，还支持 Xaml 编写用户界面，不用借助 Goft.Mvvm.light 等第三方框架原生支持数据绑定等。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:1","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"使用前置条件 Android4.0 以上； IOS6.1 以上； 开发环境 VS2013； 解决方案必须是 .Net4.5 以上，PCL 模板，Vs2013update2 可使用 SharedProject。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:2","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"适用程序 Xamarin.Forms Xamarin.iOS \u0026 Xamarin.Android 以单纯数据展示为主 程序会用到特殊的交互 快速原型、概念类程序 界面 UI 经过精心设计的程序 只会用到很少的平台特殊功能(API) 会用到很多的平台特殊功能(API) 共享代码比用户UI更加重要 用户UI比共享代码更加重要 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:3","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"Xaml相关 Forms 要针对各个平台做界面微调时 OnPlatForm ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:4","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"FormsFQA 第一次运行 Forms 程序会提示“无法链接到远程服务器” Verify the project is selected to be deployed in the Solution Configuration Manager. ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:5","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"Mvvm相关 三套框架：MvvmCross、MvvmLight、XamarinFormsLab http://blog.galasoft.ch/posts/2014/05/mvvm-light-v4-4-with-xamarin-android-support/?utm_source=tuicool MvvmLight For Android要求Android版本在2.3(API10)以上 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:6","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"FQA 一个纠缠很久的问题，Android 设计界面中 Layout 无法加载，报什么网络错误，原因为 Android SDK 升级了最新的 Tools 到 24.3，最新版的 SDK 会引起 Xamarin 出现这个错误，如果使用最新的 Xamarin 则已修复这个错误，如果不想更新 Xamarin 则需要进行 SDK 降级操作 限制屏幕旋转功能，指定程序只能使用竖屏或横屏，参考《Xamarin Forms Preview Edition 2》第五章，88(PDF 101)页。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:7","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["dotnet"],"content":"其他资源 安装、破解：http://www.jianshu.com/p/c67c14b3110c ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:8","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"}]