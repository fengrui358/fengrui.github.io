[{"categories":["utils"],"content":"概念 AutoRest 工具生成用于访问 RESTful Web 服务的客户端库。 AutoRest 的输入是使用 OpenAPI 规范格式描述 REST API 的规范。 ","date":"2022-04-07","objectID":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/:1:0","tags":["utils","autorest"],"title":"使用 AutoRest 生成接口类型代码","uri":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/"},{"categories":["utils"],"content":"流程图 流程图 ","date":"2022-04-07","objectID":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/:2:0","tags":["utils","autorest"],"title":"使用 AutoRest 生成接口类型代码","uri":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/"},{"categories":["utils"],"content":"生成客户端代码 下载 swagger.json 文件，执行以下命令： autorest --input-file=swagger.json --output-folder=./out --typescript 参考： https://github.com/Azure/autorest ","date":"2022-04-07","objectID":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/:3:0","tags":["utils","autorest"],"title":"使用 AutoRest 生成接口类型代码","uri":"/%E4%BD%BF%E7%94%A8-autorest-%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BB%A3%E7%A0%81/"},{"categories":["base"],"content":"概念 https 是在 http 的基础上，利用 TLS/SSL 加密的方式，实现了安全的通信。 ","date":"2022-03-16","objectID":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/:1:0","tags":["base","https","security"],"title":"https 请求流程","uri":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"},{"categories":["base"],"content":"流程图 https 请求流程图 ","date":"2022-03-16","objectID":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/:2:0","tags":["base","https","security"],"title":"https 请求流程","uri":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"},{"categories":["base"],"content":"证书 服务器下发的数字证书可以是向某个可靠机构申请的，也可以是自制的，证书包含以下这些内容： 证书的序列号。 证书的过期时间。 站点组织名。 站点 DNS 主机名。 站点公钥。 证书颁发者名。 证书签名。 因为证书就是供开提供给大家的，所以不需要签名。 证书的验证时由浏览器内置的 TSL 完成的，主要包括以下步骤： 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书不是权威机构颁发的，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。 用机构的证书公钥解密得到证书的内容和证书的签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前请求的网址一致，不一致会提示用户。如果网址一致就会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。 参考： https://www.jianshu.com/p/ecbae815baf2 https://zhuanlan.zhihu.com/p/43789231 ","date":"2022-03-16","objectID":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/:3:0","tags":["base","https","security"],"title":"https 请求流程","uri":"/https-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"},{"categories":["git"],"content":"git 保存用户名密码 git config --global credential.helper store ","date":"2022-03-08","objectID":"/git-%E7%AC%94%E8%AE%B0/:1:0","tags":["git"],"title":"git 笔记","uri":"/git-%E7%AC%94%E8%AE%B0/"},{"categories":["git"],"content":"获取 git 子模块 下载完主仓库后再执行一次以下命令获取子模块 git submodule update --init --recursive ","date":"2022-03-08","objectID":"/git-%E7%AC%94%E8%AE%B0/:2:0","tags":["git"],"title":"git 笔记","uri":"/git-%E7%AC%94%E8%AE%B0/"},{"categories":["git"],"content":"git 换行符设置 跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项： true: 提交时转换为 LF，检出时转换为 CRLF false: 提交检出均不转换 input: 提交时转换为LF，检出时不转换 # 提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true # 提交时转换为LF，检出时不转换 git config --global core.autocrlf input # 提交检出均不转换 git config --global core.autocrlf false 如果把 autocrlf 设置为 false 时，那另一个配置项 safecrlf 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项： true: 拒绝提交包含混合换行符的文件 false: 允许提交包含混合换行符的文件 warn: 提交包含混合换行符的文件时给出警告 # 拒绝提交包含混合换行符的文件 git config --global core.safecrlf true # 允许提交包含混合换行符的文件 git config --global core.safecrlf false # 提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn ","date":"2022-03-08","objectID":"/git-%E7%AC%94%E8%AE%B0/:3:0","tags":["git"],"title":"git 笔记","uri":"/git-%E7%AC%94%E8%AE%B0/"},{"categories":["git"],"content":"最佳设置合并 git config --global credential.helper store git config --global core.autocrlf false git config --global core.safecrlf true 参考 http://kuanghy.github.io/2017/03/19/git-lf-or-crlf ","date":"2022-03-08","objectID":"/git-%E7%AC%94%E8%AE%B0/:4:0","tags":["git"],"title":"git 笔记","uri":"/git-%E7%AC%94%E8%AE%B0/"},{"categories":["docker"],"content":"Docker 是什么？按作用来描述，它是我们日常开发运维离不开的容器化技术，它的核心是一个镜像，它的作用是将一个应用程序包装成一个容器，然后将容器放到一个网络中，这样就可以让我们的应用程序在不同的环境中运行，而不需要改变程序的代码，这样就可以节省我们的开发时间。 Docker 的本质是什么？它是利用 Linux 的 Cgroups 和 Namespace 技术实现的程序进程隔离环境，它是一个轻量级的应用程序级别的隔离技术，无论是运行性能和部署效率都高于传统的虚拟机，但是它的隔离完备性还是不如传统的虚拟机，它的底层内核还是和宿主机共用一套。利用 Cgroups 和 Namespace 实现容器化的技术还有很多，但最后 Docker 成为了受众最广泛的技术得益于它设计的这一套镜像机制，通过 rootfs 和联合文件系统实现了镜像的分层设计，将镜像设计得易于搬运和使用。 上面提到 Docker 是利用 Linux 的相关技术实现的环境隔离，那为什么 Windows 和 MacOS 也可以使用 Docker？这是因为 Docker 容器并不是直接运行在 Windows 或 MacOS 上的，在它们之间还隔着一个 Linux 虚拟机，所以在 Windows 和 MacOS 上选择 Host 网络模式时并不生效，因为 Docker 无法直接联通到宿主机的网络。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:0:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"站在进程的角度看下 Docker 当一个进程运行在 Docker 中时，很大程度上，它都会看到一个假象，那就是这个系统环境下只有自己一个进程。 为了验证这个问题，我们启动一个容器，仅运行一个 sh 进程： # 启动容器命令 docker run -it --rm busybox sh 在容器中输入命令，查看进程信息： ps --- 输出 --- PID USER TIME COMMAND 1 root 0:00 sh 9 root 0:00 ps 我们看到这个 PID 为 1 的进程就是我们进入容器运行的 sh 进程，但是它看到的1并不是宿主机上真正的 1 号进程，只是它在容器中受到 Namespace 隔离机制看到的“障眼法”。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:1:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"Cgroups 资源限制 如果说 Namespace 对容器起到了隔离作用，那么还需要一个东西来对容器进行限制，否则容器内的进程可以无限制的使用宿主机的资源肯定会对宿主机或运行在宿主机上的其他容器造成影响。 因此，承担这个职责的就是 Linux Cgroups，它的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络等。 使用 mount 指令可以把 Cgroups 的文件操作接口展示出来： $ mount -t cgroup cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids) cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb) 它的输出结果，是一系列文件系统目录。在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、memory 这样的子目录，也叫子系统。这些都是这台机器可以被 Cgroups 管理的系统组，每个系统组都有自己的资源限制。比如 CPU 子系统，我们就可以看到如下几个配置文件： $ ls /sys/fs/cgroup/cpu --- 输出 --- cgroup.clone_children cgroup.sane_behavior cpuacct.usage cpuacct.usage_percpu cpuacct.usage_percpu_user cpuacct.usage_user cpu.cfs_quota_us cpu.stat notify_on_release system.slice user.slice cgroup.procs cpuacct.stat cpuacct.usage_all cpuacct.usage_percpu_sys cpuacct.usage_sys cpu.cfs_period_us cpu.shares docker release_agent tasks 使用资源限制的方式，在 cpu 目录下，新建一个文件夹来限制进程资源，当新建一个文件夹时，操作系统会在这个子文件夹下生成对应的资源限制文件，有如下两个重要文件： $ cat cpu.cfs_quota_us -1 $ cat cpu.cfs_period_us 100000 cpu.cfs_quota_us 文件里的 -1 表示无限制，cpu.cfs_period_us 文件里的 100000 表示每个时间片的时间长度为 100ms（100000us）。 在不限制资源的情况下可以使用如下命令来执行一个死循环，可以用 top 指令看到会有一个进程占满了一个 CPU 核心： while : ; do : ; done \u0026 可以通过向 cpu.cfs_period_us 文件写入数字来改变时间片的长度，比如，向 container 组里的 cpu.cfs_period_us 写入 20ms（20000us），即意味着每 100ms的时间片，进程只能获得 20ms 的时间片： echo 20000 \u003e /sys/fs/cgroup/cpu/docker/cpu.cfs_period_us 然后在文件夹下的 tasks 文件中写入要限制的进程的 PID，上面的设置就会对该进程生效了，如果写入多个进程，意思是这个多个进程共享这一个限制： echo 226 \u003e /sys/fs/cgroup/cpu/container/tasks 在 docker run 容器时，使用 --cpu-quota 和 --cpu-period 参数可以用同样的方式来限制容器的 CPU 资源使用。 限制以后在宿主机的 /sys/fs/cgroup/cpu/docker 目录下可以看到相同容器 Id 的子文件夹，进入后查看 cpu.cfs_period_us 和 cpu.cfs_period_us 可以看见 docker run 时写入的限制就在这两个文件中。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:2:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"Mount Namespace 除了限制 CPU，docker 利用 Mount Namespace 对容器的文件系统也进行了限制。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:3:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"rootfs 根目录 docker 隔离文件系统的方式是使用 rootfs 改变了应用程序的根目录，这样进程在容器中运行时就能看见一个专为它定制的根目录，这个根目录会包括一些常见的目录和文件，比如 /bin，/etc，/proc 等。而这个虚拟的根目录在宿主机那里不过是一个被 rootfs 指定的普通的子目录。 rootfs 解决了容器随处部署都能实现环境一致的效果，而另一方 docker 在此基础上使用分层的概念创建出了镜像，使得容器的易用性得到极大提升。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:3:1","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"layer 分层镜像 layer 利用到了 linux 的一种叫做联合文件系统（Union File System）的能力。 Union File System 也叫 UnionFS，主要功能是将多个不同位置的目录联合挂载到同一目录下。 比如要将 A 录下的文件和 B 目录下的文件挂载到 C 目录下，可以使用命令： mkdir C mount -t aufs -o dirs=./A=rw:./B=ro none ./C 知道了原理，我们再回过头来看看 docker 镜像的构成，使用命令启动一个 Ubuntu 容器： docker run -d ubuntu:latest sleep 3600 查看该镜像详情，可以看见 Layers 信息： docker image inspect ubuntu:latest --- 输出 --- ... \"RootFS\": { \"Type\": \"layers\", \"Layers\": [ \"sha256:0eba131dffd015134cb310c284b776c1e44d330146cd2f0e30c4e464d0b76d24\" ] }, ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:3:2","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"容器进程的 Pid 启动一个容器后使用以下命令获取 Docker 容器的进程 Pid： docker inspect --format '{{.State.Pid}}' ee8e926d --- 输出 --- 1703 此时，通过宿主机的 proc 文件，可以看到这个进程的所有 Namespace 对应的文件： sudo ls -l /proc/1703/ns --- 输出 --- total 0 lrwxrwxrwx 1 root root 0 Jan 21 08:14 cgroup -\u003e 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Jan 21 08:12 ipc -\u003e 'ipc:[4026532648]' lrwxrwxrwx 1 root root 0 Jan 21 08:12 mnt -\u003e 'mnt:[4026532646]' lrwxrwxrwx 1 root root 0 Jan 21 08:08 net -\u003e 'net:[4026532651]' lrwxrwxrwx 1 root root 0 Jan 21 08:12 pid -\u003e 'pid:[4026532649]' lrwxrwxrwx 1 root root 0 Jan 21 08:14 pid_for_children -\u003e 'pid:[4026532649]' lrwxrwxrwx 1 root root 0 Jan 21 08:14 user -\u003e 'user:[4026531837]' lrwxrwxrwx 1 root root 0 Jan 21 08:12 uts -\u003e 'uts:[4026532647]' ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:4:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"加入容器网络 Docker 专门提供了一个参数，可以让你启动一个容器并“加入”到另一个容器的 Network Namespace 里，这个参数就是 –net，比如： docker run --net=container:ee8e926d busybox:latest ifconfig ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:5:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"Volume 挂载 容器中的目录可以通过 Volume 挂载到宿主机上，比如： docker run -d -it -v /test ubuntu:latest sleep 3600 查看刚才创建容器挂载的宿主机目录 docker inspect --format '{{.Mounts}}' 744 --- 输出 --- [{volume 16c3ad909ee3a43f42fded7424299830dd4a5c36ccbba0e2e2af701394801dca /var/lib/docker/volumes/16c3ad909ee3a43f42fded7424299830dd4a5c36ccbba0e2e2af701394801dca/_data /test local true }] 其中 /var/lib/docker/volumes/16c3ad909ee3a43f42fded7424299830dd4a5c36ccbba0e2e2af701394801dca/_data 就是容器中 /test 对应的宿主目录，在里面进行文件操作，在宿主机和容器里都能看到。 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:6:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["docker"],"content":"参考 https://time.geekbang.org/column/article/23132 ","date":"2022-01-08","objectID":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/:7:0","tags":["docker"],"title":"Docker 是什么","uri":"/docker-%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["deploy"],"content":"腾讯云 EKS ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:0","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["deploy"],"content":"EKS 介绍 弹性容器服务（Elastic Kubernetes Service，EKS）是腾讯云容器服务推出的无须用户购买节点即可部署工作负载的服务模式。弹性容器服务 EKS 完全兼容原生 Kubernetes，支持使用原生方式购买及管理资源，按照容器真实使用的资源量计费。弹性容器服务 EKS 还扩展支持腾讯云的存储及网络等产品，同时确保用户容器的安全隔离，开箱即用。 ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:1","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["deploy"],"content":"创建弹性集群 功能入口 EKS 入口 弹性集群创建 弹性集群 开启 EKS 的公网访问 公网访问 使用公网凭据连接 EKS 将本地 kubectl 的 config 切换为公网配置 KUBECONFIG=~/.kube/config:~/Downloads/cls-atdkokny-config kubectl config view --merge --flatten \u003e ~/.kube/config export KUBECONFIG=~/.kube/config 其中，~/Downloads/cls-atdkokny-config 为本集群的 kubeconfig 的文件路径，请替换为下载至本地后的实际路径。 ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:2","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["deploy"],"content":"部署 wordpress 完成以上 EKS 连接后，后续的部署步骤可完全参考这篇本地部署的文章：https://kubernetes.io/zh/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/ 准备好 kustomization.ymal 文件后运行命令部署： kubectl apply -k ./ 部署 ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:3","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["deploy"],"content":"部署完成 运行命令部署完成后，使用命令可得到公网访问 Ip：kubectl get services wordpress EXTERNAL-IP 公网访问： 公网访问 ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:4","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["deploy"],"content":"清理 运行命令清理 Deployment、Service、PVC、PV： kubectl delete -k ./ 再手动关闭之前的公网访问，这样可以停掉 EKS 的所有计量收费项目，至此，这样一个简单的 EKS 应用部署流程结束。 参考 https://tke-2gipdtus3676b965-1251009918.ap-shanghai.app.tcloudbase.com/docs/k8s-project#4kubernetes%E5%AD%98%E5%82%A8 https://kubernetes.io/zh/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/ ","date":"2021-12-28","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/:1:5","tags":["k8s","deploy"],"title":"使用腾讯云 EKS 部署 WordPress","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91-eks-%E9%83%A8%E7%BD%B2-wordpress/"},{"categories":["dotnet"],"content":"dotnet-counters 性能诊断 ","date":"2021-12-14","objectID":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/:1:0","tags":["dotnet, diagnosis"],"title":"Dotnet 程序诊断","uri":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/"},{"categories":["dotnet"],"content":"介绍 https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/dotnet-counters ","date":"2021-12-14","objectID":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/:1:1","tags":["dotnet, diagnosis"],"title":"Dotnet 程序诊断","uri":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/"},{"categories":["dotnet"],"content":"安装 dotnet tool install --global dotnet-counters ","date":"2021-12-14","objectID":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/:1:2","tags":["dotnet, diagnosis"],"title":"Dotnet 程序诊断","uri":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/"},{"categories":["dotnet"],"content":"收集 查看可监视的 dotnet 进程列表 dotnet-counters ps 以 3 秒的刷新间隔时间收集所有计数器的值，并生成 csv 输出文件： dotnet-counters collect --process-id 1902 --refresh-interval 3 --format csv 实时监控 dotnet-counters monitor --refresh-interval 1 -p 22884 筛选监控指标 dotnet-counters monitor --counters System.Runtime[cpu-usage,gc-heap-size] -p 22884 --refresh-interval 1 参考 https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/ https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/debug-memory-leak https://docs.microsoft.com/zh-cn/dotnet/core/diagnostics/debug-deadlock?tabs=windows ","date":"2021-12-14","objectID":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/:1:3","tags":["dotnet, diagnosis"],"title":"Dotnet 程序诊断","uri":"/dotnet-%E7%A8%8B%E5%BA%8F%E8%AF%8A%E6%96%AD/"},{"categories":["deploy"],"content":"Fastdfs 介绍 Fastdfs 是一款流行的分布式文件系统，具有文件自动同步，防止单点故障等特性，官网地址：https://github.com/happyfish100/fastdfs ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"部署 采用 Docker 部署，使用官网提供的 Docker 文件稍加修改，截止 2021-11-09 日，在 github 官网项目中可以看见两套部署方案，一套 local 和一套 network，local 就是将一些会提前用到的包下载到本地，防止国内访问 dockerhub 网络不好的情况，但是经过实际测试，这个方案会有问题，于是直接采用 network 方式：https://github.com/happyfish100/fastdfs/tree/master/docker/dockerfile_network ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"启动 tracker 使用命令 fdfs_trackerd /etc/fdfs/tracker.conf restart 启动 tracker 查看日志文件 cat /root/fastdfs/logs/trackerd.log 显示 [2021-11-09 04:24:55] INFO - FastDFS v6.07, base_path=/home/dfs, ... 表示启动成功 ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:1","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"启动 storage 使用命令 fdfs_storaged /etc/fdfs/storage.conf restart 启动 storage 查看日志文件 cat /root/fastdfs/logs/storaged.log 显示 [2021-11-09 04:24:55] INFO - FastDFS v6.07, base_path=/home/dfs, ... 表示启动成功 服务启动后进入容器内部，输入命令 fdfs_monitor /etc/fdfs/storage.conf，可以查看 storage 是否已注册到 tracker。 ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:2","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"Nat 网络 大多数情况下 storage 是部署在内网当中，当其向 tracker 注册时，tracker 拿到的只是 storage 的内网 ip，此时需要使用双 ip 模式部署，参考 https://www.jianshu.com/p/b16922f71375#_Toc18054 中的 “Storage server服务器双IP设置” ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:3","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"实际分离部署 官网的 docker 配置是把 tracker、storage、nginx 通过 Dockerfile 打包在一起，我将 tracker 和 storage、nginx 分离成了两个包，并且将配置文件也独立出来，按照我的习惯，使用 docker-compose 配合 volumes 映射配置文件进行部署。tracker 地址 fengrui358/fastdfs_tracker，storage 地址 fengrui358/fastdfs_storage。配置文件以 github 官网为基础修改，放在 conf 目录下。 tracker docker compose config: fastdfs_tracker: image: 'fengrui358/fastdfs_tracker' container_name: fastdfs_tracker restart: always networks: - \"fastdfs_network\" ports: - \"22122:22122\" # tracker_server volumes: - ./conf:/etc/fdfs # 配置 - ./data:/home/dfs # 数据 storage docker compose config: fastdfs_storage: image: 'fengrui358/fastdfs_storage' container_name: fastdfs_storage restart: always networks: - \"fastdfs_network\" ports: - \"23000:23000\" # stoage_server - \"8011:80\" #nginx web volumes: - ./conf:/etc/fdfs # 配置 - ./data:/home/dfs # 数据 - ./conf:/usr/local/nginx/conf # nginx 配置 ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:4","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"客户端测试 使用了一个 Dotnet 客户端进行测试，https://github.com/caozhiyuan/FastDFSNetCore 参考： http://www.ityouknow.com/fastdfs/2017/10/10/cluster-building-fastdfs.html https://www.jianshu.com/p/b16922f71375#_Toc18054 ","date":"2021-11-09","objectID":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","fastdfs"],"title":"Fastdfs 部署与使用","uri":"/fastdfs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"ELK 介绍 ELK 是一套可用来收集、分析、展示日志信息的工具，主要由三部分组成： Logstash：Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据。（现在 ELK 增加了新的工具家族 Beats，其中包括 FileBeat 来读取日志文件并发送，更加简便轻量） Elasticsearch: 用于存储和分析日志。 kibana: 可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。 ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"部署 使用 Docker 部署，参考 https://github.com/deviantony/docker-elk Clone 项目 修改模式密码，我是全局搜索的 changeme 并替换为自己的密码，官网也有一套使用非特权账户的方案 https://github.com/deviantony/docker-elk#setting-up-user-authentication 修改 elasticsearch.yml 配置中的 xpack.license.self_generated.type 为 basic，不使用收费功能 修改 kibana.yml 中的 server.publicBaseUrl 为要配置的域名：http://log.frhello.com:5601 构建启动：docker-compose up ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"登录 kibana 如果没有修改密码使用默认账户 elastic 加默认密码登录，默认地址 localhost:5601 ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"日志写入 使用文件采集的方式写入日志，参考：https://www.elastic.co/guide/en/beats/filebeat/7.14/filebeat-installation-configuration.html 中文参考：https://cloud.tencent.com/developer/article/1667569 ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"filebeat filebeat 是一个轻量级的文件日志记录器，可以将本机的日志文件发送到指定的 logstash 或 elastic filebeat docker hub 镜像：https://hub.docker.com/r/elastic/filebeat filebeat docker 使用说明：https://www.elastic.co/guide/en/beats/filebeat/current/running-on-docker.html#_custom_image_configuration filebeat 配置：https://www.elastic.co/guide/en/beats/filebeat/7.14/configuring-howto-filebeat.html filebeat 配置：https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-reference-yml.html filebeat 配置中通过 keystore 存储敏感数据：https://www.elastic.co/guide/en/beats/filebeat/current/keystore.html ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:1","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"各语言写入日志 ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"直接使用 Elastic Common Schema (ECS) 直接使用 Elastic 的 json 日志格式，无需再次转换：https://www.elastic.co/guide/en/ecs-logging/overview/master/intro.html https://github.com/elastic/ecs-dotnet/tree/master/src/Elastic.CommonSchema.NLog 需要注意在 filebeat.yaml 配置中添加解码 json 的相关配置 json.keys_under_root: true json.overwrite_keys: true json.add_error_key: true json.expand_keys: true ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:1","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"C# Nlog 日志组件有一个直接写入 elastic 的 target：https://github.com/markmcdowell/NLog.Targets.ElasticSearch Serilog 和 NLog ESC 日志：https://www.elastic.co/guide/en/ecs-logging/dotnet/master/setup.html ESC 文档：https://www.elastic.co/guide/en/ecs/current/index.html 参考 官方文档： https://www.elastic.co/guide/cn/kibana/current/introduction.html ","date":"2021-10-27","objectID":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:2","tags":["deploy","elk"],"title":"ELK 部署与使用","uri":"/elk-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["package"],"content":"创建 npm 包 为了创建全平台适用的 npm 包，这里使用了一个第三方的脚手架 jslib 来创建项目工程。 使用 npm 全局安装 jslib，npm i -g @js-lib/cli。 运行 jslib new mylib 创建新的工程，会有一段交互式输入，按需填写。 在 src 目录下完成工程代码的逻辑编写。 ","date":"2021-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:1:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"修改 version 提交所有修改，执行命令修改版本号。 # patch：这个是补丁的意思，补丁最合适； # minor：这个是小改； # major：这个是大改； npm version patch npm version minor npm version major ","date":"2021-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:2:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"更改 registry 使用 npm config get registry 查看 registry 配置，如果不是 https://registry.npmjs.org，需要运行 npm config set registry https://registry.npmjs.org 进行修改，包上传完毕后修改为淘宝环境 https://registry.npm.taobao.org 加速 npm。 ","date":"2021-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:3:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"登陆 npm 使用 npm login 进入交互式输入，输入用户名密码登陆。 ","date":"2021-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:4:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["package"],"content":"发布 使用 npm publish 发布包。 ","date":"2021-10-09","objectID":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/:5:0","tags":["npm","package"],"title":"使用 jslib 创建发布 npm 包","uri":"/%E4%BD%BF%E7%94%A8-jslib-%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"},{"categories":["deploy"],"content":"SRS 介绍 Fastdfs 是一个简单高效的实时视频服务器，支持RTMP/WebRTC/HLS/HTTP-FLV/SRT，官网地址：https://github.com/ossrs/srs ","date":"2021-09-15","objectID":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","srs"],"title":"SRS 部署与使用","uri":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"部署 使用 docker 部署方式，参考：https://github.com/ossrs/srs/wiki/v4_CN_Home#getting-started ","date":"2021-09-15","objectID":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","srs"],"title":"SRS 部署与使用","uri":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"测试 启动 srs server，其中的1985端口不太明白作用 docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 ossrs/srs ./objs/srs -c conf/srs.conf 启动推流，将下面的 -y rtmp://localhost/live/livestream 中的 localhost 修改为实际地址 docker run --rm ossrs/srs:encoder ffmpeg -re -i ./doc/source.200kbps.768x320.flv -c copy -f flv -y rtmp://localhost:1935/live/livestream ","date":"2021-09-15","objectID":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","srs"],"title":"SRS 部署与使用","uri":"/srs-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"Mutagen 介绍 该工具的一个主要作用是在不同系统之间同步文件数据，主要支持本地文件系统，远程服务器和 Docker 容器文件同步。Github 地址：https://github.com/mutagen-io ","date":"2021-09-12","objectID":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","mutagen"],"title":"Mutagen 安装和使用","uri":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"安装 跟随官网使用 brew 安装，https://mutagen.io/documentation/introduction/installation ","date":"2021-09-12","objectID":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","mutagen"],"title":"Mutagen 安装和使用","uri":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"文件同步 mutagen sync create --name=rats1 /moerats ubuntu@xxx.xxx.xxx.xxx:22:/home/ubuntu/rats 参考： https://www.moerats.com/archives/980/ ","date":"2021-09-12","objectID":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","mutagen"],"title":"Mutagen 安装和使用","uri":"/mutagen-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"工具 https 的场景运用越来越广泛，有时在开发环境中也需要使用 https 来进行开发或测试，这时自签名证书就成了快速应对这一场景的省时省力的好帮手。 常见的自签名方案有通过 OpenSSL 来生成，不过现在有更快捷方便的工具 https://github.com/FiloSottile/mkcert。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:1:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"生成证书 Windows 下能够下载对应的工具 https://github.com/FiloSottile/mkcert/releases，使用命令生成本地域名证书 mkcert-v1.4.3-windows-amd64.exe localhost 127.0.0.1 ::1 10.13.69.59 192.168.1.80 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:2:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"安装证书 mkcert-v1.4.3-windows-amd64.exe -install ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:3:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"配置 nginx ssl_certificate \"/etc/nginx/conf.d/localhost+4.pem\"; ssl_certificate_key \"/etc/nginx/conf.d/localhost+4-key.pem\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; 到此，浏览器应该能够使用 https 正常访问网页，不过期间有个小插曲，因为我的 Windows 电脑安装的 VMware，这玩意有个 VMwareHostd 服务监听了 443 端口，导致我的浏览器一直在报 NET:ERR_CERT_AUTHORITY_INVALID 这个错误，但是我更换 nginx 代理暴露的端口后又能正常访问，这一度让我以为 443 端口对浏览器来说有某种神秘力量，好在后来停掉 nginx 后发现 443 依旧可以 telnet 通，这才知道原来是被 VMwareHostd 占用了，停掉这个服务后就一切正常了。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:4:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"复用根证书 通过命令 mkcert -CAROOT 查看根证书的位置，查看到证书位置后取一份计算机的证书，复制到其他计算机后运行 mkcert -install 就可以达到不同计算机都能识别相同的自签证书的目的。 ","date":"2021-09-10","objectID":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/:5:0","tags":["https","cert"],"title":"生成 https 证书并使用","uri":"/%E7%94%9F%E6%88%90-https-%E8%AF%81%E4%B9%A6%E5%B9%B6%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"介绍 Janus 是由 Meetecho 开发的 WebRTC 服务器。因此，除了实现与浏览器建立 WebRTC 媒体通信、与其交换 JSON 消息以及在浏览器和服务器端应用程序逻辑之间中继 RTP/RTCP 和消息的方法之外，它本身不提供任何功能。任何特定的功能和应用程序都由服务器端插件提供，浏览器可以通过 Janus 联系以利用它们提供的功能。此类插件的示例可以是应用程序的实现，例如回声测试、会议桥、媒体记录器、SIP 网关等。 ","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:1:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"部署 我使用了一个 docker hub 镜像 来部署 janus 的后台，部署方法可参考 https://janus.conf.meetecho.com/docs/deploy，再搭配一个 nginx 来做后台 API 的转发，docker-compose 配置如下： version: '2.1' services: janus-gateway: image: 'canyan/janus-gateway' container_name: janus_gateway command: [\"/usr/local/bin/janus\", \"-F\", \"/usr/local/etc/janus\"] volumes: - \"./etc/janus/janus.jcfg:/usr/local/etc/janus/janus.jcfg\" # - \"./etc/janus/janus.eventhandler.sampleevh.jcfg:/usr/local/etc/janus/janus.eventhandler.sampleevh.jcfg\" restart: always network_mode: 'host' janus_nginx: image: nginx:alpine container_name: janus_nginx restart: always network_mode: 'host' volumes: - ./conf.d/:/etc/nginx/conf.d - ./html:/dist 有一点需要注意，如果 janus 安装在 nat 转换后的内网需要 trun 来帮助客户端和服务端打洞，部署复杂，而且失败率很高，因此将 janus 的服务部署为与主机共享网络的 host 模式，当然前提是你要有一台有公网 ip 的服务器。 虽然部署在公网，但是还是需要一个 stun 服务，在 janus.jcfg 配置中需要取消 stun 的注释： stun_server = \"stun.voip.eutelia.it\" stun_port = 3478 nginx 配置如下，里面我使用了对应域名的 https 证书： server { listen 80; server_name web_dist; location / { root /dist; index index.html index.htm; } } server { listen 80 default_server; listen [::]:80 default_server; server_name localhost; rewrite ^(.*)$ https://$host$1 permanent; root /dist; } # api server upstream api_server{ server 127.0.0.1:8088; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } upstream websocket { server 127.0.0.1:8188; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name localhost; root /dist; underscores_in_headers on; ssl_certificate \"/etc/nginx/conf.d/ctxy.frhello.comert.pem\"; ssl_certificate_key \"/etc/nginx/conf.d/txy.frhello.com.key\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # error_page 497 301 =307 location / { } # 后台接口 location /janus/ { proxy_pass http://api_server/janus/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Server $host; } # ws location /ws { proxy_pass http://websocket; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } nginx 中的 web 前端使用的是官网 github 项目中的演示 html 文件夹，整理好整个工程的目录： ","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:2:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["deploy"],"content":"JavaScript API 在源代码下有一个 html 文件夹下有演示 demo，在每个页面对应的 js 文件下可以配置服务地址的 websocket 地址：server = \"wss://\" + window.location.hostname + \"/ws\";，然后在 nginx 中修改配置做为这个 web 服务的代理。 最后打开 Video Room 的效果： Video Room ","date":"2021-09-04","objectID":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/:3:0","tags":["deploy","janus","webrtc"],"title":"Janus 的搭建与 WebRTC 使用","uri":"/janus-%E6%90%AD%E5%BB%BA%E4%B8%8E-webrtc-%E4%BD%BF%E7%94%A8/"},{"categories":["base"],"content":"概念 UUIDs (Universally Unique IDentifier)，也称为 GUIDs (Globally 唯一标识符）。一个 UUID 是 128 位长，并且可以保证空间和时间上的唯一性。 使用 UUID 的主要原因之一是无需集中的管理，并且 UUID 的生成算法要求它支持单台每秒超过百万次的生成速率。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:1:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"布局和字节顺序 UUID 呈现的格式为：f81d4fae-7dec-11d0-a765-00a0c91e6bf6 字段 数据类型 字节 注释 time_low unsigned 32 bit integer 0-3 低域位整数时间戳 time_mid unsigned 16 bit integer 4-5 中间字段位整数时间戳 time_hi_and_version unsigned 16 bit integer 6-7 高场位整数时间戳 clock_seq_hi_and_reserved unsigned 8 bit integer 8 整数时钟序列与多路复用 clock_seq_low unsigned 8 bit integer 9 低域位整数时钟序列 node unsigned 48 bit integer 10-15 空间唯一位整数节点标识符 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"版本 版本号在时间戳的最高 4 位（time_hi_and_version 的 4-7 bit） UUID 的变体规则如下 Msb0 Msb1 Msb2 Msb3 版本 描述 0 0 0 1 v1 基于时间的版本 0 0 1 0 v2 DEC 安全版本 0 0 1 1 v3 基于名称的版本（本文件中规定使用 MD5 散列） 0 1 0 0 v4 随机或伪随机生成的版本 0 1 0 1 v5 基于名称的版本（本文件中规定使用 SHA-1 散列） 版本更准确地说应该叫子类型，称其为版本只是为了兼容性。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:1","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"时间戳 时间戳是一个 60 位的值，一般使用 UTC 时间表示，如果没有 UTC 时间可用本地时间，但是尽量不建议这样做，因为本地时间要生成 UTC 时间需要额外的时区信息。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:2","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"时间序列 时间序列用于帮助避免当时钟向后设置时可能出现的重复或者节点 ID 改变。如果已知时钟序列的先前值，则它智能递增，否则它应该设置为随机或者高质量的伪随机值。类似地，如果节点 ID 发生变化（例如，因为网卡在机器间移动），需要重新设置时间序列。 对于 UUID 的版本 3 或 5，时钟序列是 14 位根据名称描述构造的值。 对于 UUID 的版本 4，时钟序列是随机或伪随机的 14 位值。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:3","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"节点 对于 UUID 的版本 1，节点字段包含一个 IEEE 802 MAC 地址，通常是主机地址。 对于 UUID 的版本 3 或 5，节点字段是 48 位根据名称描述构造的值。 对于 UUID 的版本 4，节点字段是随机或伪随机生成 48 位值。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:4","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"nil UUID nil UUID 是 UUID 的特殊形式，是所有 128 位均设置为零。 ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:2:5","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["base"],"content":"顺序 UUID 在数据库中存储，经常使用 UUID 作为主键，但是 UUID 有个致命缺陷，就是没有顺序。如果这种无顺序的 ID 当作主键在数据库中使用会严重影响数据库的性能。 现在有很多框架使用的算法支持生成递增的 UUID，例如 ABP 框架里的顺序 ID 参考了 https://github.com/jhtodd/SequentialGuid/blob/master/SequentialGuid/Classes/SequentialGuid.cs，这个顺序 ID 有个生成类型枚举 SequentialGuidType，SQL Server 使用 SequentialAtEnd 类型，因为 SQL Server 使用最低的有效 6 个字节来排序，其他大多数数据库应该传递 SequentialAsString 或 SequentialAsBinary。 UUID v1 也定义了基于时间的版本，但是该标准将时间戳拆分为几块，限制了其作为顺序 ID 的用途。因此这种顺序 UUID 与传统的 UUID 标准不兼容。 这个算法使用了 6 个字节 48 bit 来表示时间戳，精确到毫秒，大概能使用 5900 年，对于一般的应用足够了。 还有一个时间精度更高的实现方案：https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql/blob/ebe011a6f1b2a2a9709fe558cfc7ed3215b55c37/src/EFCore.MySql/ValueGeneration/Internal/MySqlSequentialGuidValueGenerator.cs，时间戳占 8 字节，精度到 100 ns，但是这个实现里有一些位移操作符，还结合了 UUID 的变体版本号，没有细看，猜测思路应该跟第一种顺序 UUID 也类似。 参考 https://www.ietf.org/rfc/rfc4122.txt ","date":"2021-09-04","objectID":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/:3:0","tags":["base","uuid"],"title":"UUID（GUID）不同版本和顺序递增探究","uri":"/uuidguid%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%92%8C%E9%A1%BA%E5%BA%8F%E9%80%92%E5%A2%9E%E6%8E%A2%E7%A9%B6/"},{"categories":["javascript"],"content":"Javascript 最常用的时间库 moment ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:0:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"初始化 moment 从 Date 初始化 let nowDate = new Date(); console.log('1.1 从 date 初始化：', nowDate, moment(nowDate)); 直接初始化 let nowMoment = moment(); console.log('1.2 直接初始化：', nowMoment); 从字符串初始化 const ISO8601_String = (new Date(1987, 8, 15 , 16, 15, 45)).toISOString(); console.log('1.3 从字符串初始化：', ISO8601_String, moment(ISO8601_String), new Date(Date.parse(ISO8601_String))) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"格式化 Format 格式化输出 console.log('2.1 Format 格式化输出：', nowMoment.format()) Format 默认格式化 moment.defaultFormat = 'YYYY-MM-DD HH:mm:ss:SSSS' console.log('2.2 Format 默认格式化输出：', nowMoment.format()) UTC Format 格式化输出 console.log('2.3 Format 格式化输出：', nowMoment.utc().format()) UTC Format 默认格式化 moment.defaultFormatUtc = 'YYYY-MM-DD HH:mm:ss:SSSS' console.log('2.4 UTC Format 默认格式化输出：', nowMoment.utc().format()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"Unix 时间戳 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"原生获取时间戳 console.log('3.1 原生获取时间戳：', nowDate.getTime(), new Date(nowDate.getTime())) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"moment 获取时间戳 console.log('3.1 moment 获取时间戳：', nowMoment.unix(), moment.unix(nowMoment.unix()), moment(nowDate.getTime())) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:3:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时区 使用 Moment Timezone ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:4:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"猜测当前时区 console.log('4.1 获取当前时区：', moment.tz.guess(), moment.utc()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:4:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时间临界值 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取当天最后一刻 console.log('5.1 获取当天最后一刻', moment().endOf('day')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取本周最后一刻 console.log('5.2 获取本周最后一刻', moment().endOf('week').startOf('day')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取本月第一天 console.log('5.3 获取本月第一天', moment().startOf('month')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:3","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"获取明年第一天 console.log('5.4 获取明年第一天', moment().year(moment().year() + 1).startOf('year')) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:5:4","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"时长 ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:0","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"原生时长差值 const d1 = new Date(1987, 8, 15, 16, 15, 45) const d2 = new Date(1987, 8, 15, 17, 13, 45) console.log('6.1 原生时长差值（单位 ms）：', d2.getTime() - d1.getTime(), d1.getTime() - d2.getTime()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:1","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"moment 时长差值减 console.log('6.3 moment 时长差值减：', duration.subtract(moment.duration(5, 'minute')).asMinutes()) ","date":"2021-08-29","objectID":"/javascript-date-%E7%AC%94%E8%AE%B0/:6:2","tags":["javascript","moment"],"title":"Javascript Date 笔记","uri":"/javascript-date-%E7%AC%94%E8%AE%B0/"},{"categories":["docker"],"content":"制作 Dockerfile 比如要打包 mkcert 方便以后快速制作 https 证书的镜像，可使用如下步骤，任意目录下新建一个 mkcert 目录，新建 Dockerfile 文件，写入以下 Dockerfil : FROM homebrew/brew RUN brew install mkcert ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:1:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["docker"],"content":"编译本地镜像 在刚才的 mkcert 目录下运行 docker build -t mkcert:v1 .，制作镜像 ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:2:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["docker"],"content":"上传镜像 制作完毕后可以上传镜像到 docker hub，重命名刚才的镜像，需要在前面加上你的 docker hub 的用户名： docker image tag mkcert:v1 {username}/mkcert:latest，最后一步上传：docker push {username}/mkcert:latest ","date":"2021-08-28","objectID":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/:3:0","tags":["docker"],"title":"Dockerfile 制作镜像上传 Docker hub","uri":"/dockerfile-%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0-docker-hub/"},{"categories":["linux"],"content":"文件夹新建 mkdir test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"文件新建 touch test.st ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"查看文件或文件夹信息 ls -l test.st ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"修改权限 # 递归修改为最高权限 chmod -R 777 test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"删除文件 rm -rf test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:5:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"压缩文件夹 tar zcvf ./t1.tar.gz test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:6:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"解压文件 # 解压到当前目录 tar zxvf t1.tar.gz # 解压到指定目录 tar zxvf t1.tar.gz -C /test ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:7:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"拷贝文件 ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:0","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"本地拷贝 # 拷贝文件 scp t1.tar.gz t2.tar.gz # 拷贝文件夹 scp -r test test2 ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:1","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"远程拷贝 # 拷贝文件 scp ubuntu@txy.frhello.com:/home/ubuntu/t1.tar.gz d:\\ # 递归拷贝文件夹 scp -r ubuntu@txy.frhello.com:/home/ubuntu d:\\ ","date":"2021-08-18","objectID":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:8:2","tags":["linux"],"title":"Linux 文件操作","uri":"/linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"安装 CentOS 下载对应版本 http://centos.01link.hk/7.9.2009/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso 虚拟机安装，注意安装以太网并设置自动对时，使用 ip addr 可查看 ip 更新 yum，然后安装 net-tools yum update yum -y install epel-release yum install net-tool ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:1:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"网络 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"防火墙 查看防火墙状态 systemctl status firewalld 打开指定端口： firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reload firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reload systemctl status firewalld 查看打开的端口： firewall-cmd --list-ports 关于 firewall 的详细配置查看 https://wangchujiang.com/linux-command/c/firewall-cmd.html ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 Telnet 工具 yum install telnet.x86_64 -y ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:2","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"静态 IP CentOS 7 静态 IP 参考 https://www.cnblogs.com/freeweb/p/5335973.html 打开配置文件进行编辑 vim /etc/sysconfig/network-scripts/ifcfg-${xxxx} 把 BOOTPROTO=\"dhcp\" 改成 BOOTPROTO=\"static\" BROADCAST=192.168.1.255 IPADDR=192.168.1.33 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 配置 DNS，配置文件位置是：/etc/resolv.conf nameserver 114.114.114.114 nameserver 8.8.8.8 重启网络 service network restart Ubuntu 18.04 静态 IP 参考 https://ld246.com/article/1593929878472 修改配置的 yaml 文件，文件位于 /etc/netplan/ 目录下，文件名类似于 00-installer-config.yaml： sudo nano /etc/netplan/00-installer-config.yaml 修改为如下配置： network: ethernets: ens160: #配置的网卡的名称 addresses: [192.168.0.105/24] #配置的静态ip地址和掩码 dhcp4: no #关闭DHCP，如果需要打开DHCP则写yes optional: true gateway4: 192.168.0.1 #网关地址 nameservers: addresses: [114.114.114.114,180.76.76.76] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开 version: 2 renderer: networkd #指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd 注意修改网卡的配置名。 最后重启网络生效： sudo netplan apply ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:2:3","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"软件 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 JDK 下载对应版本 https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html 拷贝包 scp E:\\Download\\jdk-8u281-linux-x64.rpm root@192.168.197.133:/tmp 添加执行权限 chmod +x /tmp/jdk-8u281-linux-x64.rpm rpm 安装 rpm -ivh /tmp/jdk-8u281-linux-x64.rpm chmod +x /tmp/jdk-8u281-linux-x64.rpm rpm -ivh /tmp/jdk-8u281-linux-x64.rpm ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 MySQL 下载对应版本 https://dev.mysql.com/downloads/mysql/ 安装和配置参考：https://juejin.cn/post/6844903870053761037 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:2","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"安装 Node.js cd /usr/local/src/ wget https://nodejs.org/dist/v14.15.4/node-v14.15.4.tar.gz tar zxvf node-v14.15.4.tar.gz cd node-v14.15.4 ./configure --prefix=/usr/local/node/14.15.4 make make install 配置 NODE_HOME，进入 profile 编辑环境变量 vim /etc/profile 设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejs export NODE_HOME=/usr/local/node/14.15.4 export PATH=$NODE_HOME/bin:$PATH ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:3","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"RabbitMQ 安装 安装参考 https://www.rabbitmq.com/install-rpm.html 安装 erlang 依赖 curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang-23.2.6-1.el7.x86_64 -y 安装 rabbitmq rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash sudo yum install rabbitmq-server.noarch -y 启动 rabbitmq systemctl enable rabbitmq-server.service systemctl start rabbitmq-server.service 启动管理页面 https://www.rabbitmq.com/management.html rabbitmq-plugins enable rabbitmq_management rabbitmq-plugins list 启动 stomp-web https://www.rabbitmq.com/web-stomp.html rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins list 增加用户 rabbitmqctl add_user admin admin rabbitmqctl set_user_tags admin administrator rabbitmqctl set_permissions -p \"/\" \"admin\" \".*\" \".*\" \".*\" rabbitmqctl list_users 打开防火墙 firewall-cmd --add-port=15672/tcp --permanent firewall-cmd --add-port=5672/tcp --permanent firewall-cmd --add-port=15674/tcp --permanent firewall-cmd --reload firewall-cmd --list-port # intsall erlang curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash sudo yum install erlang-23.2.6-1.el7.x86_64 -y # install rabbitmq server rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash sudo yum install rabbitmq-server.noarch -y # start rabbitmq server systemctl enable rabbitmq-server.service systemctl start rabbitmq-server.service # start management ui rabbitmq-plugins enable rabbitmq_management # start stomq-web rabbitmq-plugins enable rabbitmq_web_stomp # add user rabbitmqctl add_user admin admin rabbitmqctl set_user_tags admin administrator rabbitmqctl set_permissions -p \"/\" \"admin\" \".*\" \".*\" \".*\" # open firewall port firewall-cmd --add-port=15672/tcp --permanent firewall-cmd --add-port=5672/tcp --permanent firewall-cmd --add-port=15674/tcp --permanent firewall-cmd --reload ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:4","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"nginx 安装 参考 https://www.nginx.com/resources/wiki/start/topics/tutorials/install/ 在/etc/yum.repos.d目录下添加源文件nginx.repo，然后配置源： [nginx] name=nginx repo baseurl=https://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 执行命令安装，yum install nginx ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:3:5","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"设置常驻服务 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:4:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"Ubuntu 设置常驻服务 https://www.jianshu.com/p/5ffccbd8ed1b https://blog.csdn.net/wojiaosha123/article/details/98784936 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:4:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"sudo 免密 ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:5:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"Ubuntu sudo 免密 进入 /etc/sudoers.d/ 目录，新建一个跟用户名同名的文件，然后在里面录入 yourusername ALL=(ALL) NOPASSWD:ALL ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:5:1","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["linux"],"content":"免密登陆 参考：https://zhuanlan.zhihu.com/p/35878555 https://docs.github.com/cn/github/authenticating-to-github/working-with-ssh-key-passphrases Windows 下添加ssh-agent：https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement ","date":"2021-05-28","objectID":"/linux-%E7%AC%94%E8%AE%B0/:6:0","tags":["linux"],"title":"Linux 笔记","uri":"/linux-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"教程 https://docs.microsoft.com/en-us/ef/core/ ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"Ef 命令使用 使用 EF CLI 安装 dotnet tool install --global dotnet-ef 使用 PMC (Package Manager Console，Visual Studio 推荐使用该方式，可以减少文件夹切换等操作) 安装 Install-Package Microsoft.EntityFrameworkCore.Tools ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"核心 nuget 程序集 Microsoft.EntityFrameworkCore Microsoft.EntityFrameworkCore.Relational Microsoft.EntityFrameworkCore.database provider Microsoft.EntityFrameworkCore.Design （设计时，用于由 model 生成数据库或者反向， 可以不随生成发布） 程序集的各版本需要一致 ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["efcore"],"content":"自动生成 SQL 的相关命令 dotnet 命令 PowerShell 命令 作用 dotnet ef migrations add InitialCreate Add-Migration InitialCreate 对当前的 EF Model 的更改，增加一个 Migration 的配置文件 dotnet ef database update Update-Database 更新当前的 Migration 到数据库中 dotnet ef migrations remove Remove-Migration 删除一个最新的 Migration dotnet ef database update LastGoodMigartion Update-Database LastGoodMigration 指定一个 Migration 去更新数据库 dotnet ef migrations script Script-Migration 将当前的 Migrationn 生成 SQL 脚本，SQL 脚本可以直接拿来使用 使用命令前需要引用 Microsoft.EntityFrameworkCore.Tools 这个包 ","date":"2021-05-10","objectID":"/entity-framework-core-%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","efcore"],"title":"Entity Framework Core 笔记","uri":"/entity-framework-core-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"参考：https://vmsdurano.com/apiboilerplate-and-identityserver4-access-control-for-apis/ ","date":"2021-05-03","objectID":"/identity-server-4/:0:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"接口发现 Token Endpoint https://localhost:44354/.well-known/openid-configuration ","date":"2021-05-03","objectID":"/identity-server-4/:1:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"Issuer 不一致导致验证失败 https://www.cnblogs.com/stulzq/p/10339024.html ","date":"2021-05-03","objectID":"/identity-server-4/:2:0","tags":["dotnet","aspnetcore","identity","resource"],"title":"Identity Server 4","uri":"/identity-server-4/"},{"categories":["aspnetcore"],"content":"框架介绍 旧版 Abp 框架，https://aspnetboilerplate.com/ 新版 Abp 框架，扩展了对微服务的支持，https://abp.io/ 结构介绍：https://docs.abp.io/en/abp/latest/Best-Practices/Module-Architecture ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"内置模块 https://docs.abp.io/en/abp/latest/Modules/Index ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"领域层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"EF Core https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Migrations ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"IRepository 内置方法 https://docs.abp.io/en/abp/latest/Repositories ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:2","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"异步查询执行 IAsyncQueryableExecuter.ToListAsync() https://docs.abp.io/en/abp/latest/Repositories ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:3","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"对象扩展 扩展 Abp 框架自带模块对应的数据库实体 https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Extending-Entities ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:4","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"实体变更通知 ILocalEventHandler\u003cEntityChangedEventData\u003c\u003e\u003e ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:3:5","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"应用层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"服务层 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"替换内置 Service 和 Control https://docs.abp.io/en/abp/latest/Customizing-Application-Modules-Overriding-Services ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"权限 https://docs.abp.io/en/abp/latest/Authorization ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:5:2","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"基础设施 ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:6:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"配置 https://docs.abp.io/en/abp/latest/Configuration https://docs.abp.io/en/abp/latest/Settings ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:6:1","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["aspnetcore"],"content":"参考文章 https://www.cnblogs.com/myzony/p/11312928.html ","date":"2021-04-26","objectID":"/abp-%E7%AC%94%E8%AE%B0/:7:0","tags":["dotnet","aspnetcore","abp","resource"],"title":"Abp 笔记","uri":"/abp-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"loader 处理特定后缀名的模块称为 loader thread-loader: 使用线程池加速打包过程 ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:1:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"占位符 占位符名称 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件相对路径 [folder] 文件所在的文件夹 [contenthash] 文件的内容 hash，默认是 MD5 生成 [hash] 文件内容的 hash，默认是 MD5 生成 [emoji] 一个随机的指代文件内容的 emoji ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:1:1","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"plugins 插件用于 bundle 文件的优化，资源管理和环境变量的注入 作用于整个构建过程，如：构建前删除 dist 目录 ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:2:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":"Mode Mode 用来指定当前的构建环境，production，development，none 设置 mode 可以使用 webpack 内置的函数，默认值为 production ","date":"2021-03-21","objectID":"/webpack-%E7%AC%94%E8%AE%B0/:3:0","tags":["package","webpack"],"title":"webpack 笔记","uri":"/webpack-%E7%AC%94%E8%AE%B0/"},{"categories":["docker"],"content":"账号权限 创建 docker 组 sudo groupadd docker 添加用户到该组 sudo usermod -aG docker ${USER} 重新登陆系统 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"建立网络 docker network create -d bridge my-net -d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode 每一个 bridge 网络均为独立子网，如果要在 bridge 网络中的容器里访问宿主机网络需要使用 host.docker.internal 来解析宿主机真实地址 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"加入容器网络 使用以下命令加入一个运行中的容器网络，可以进行一些网络诊断 docker run --network xxxx_network -it busybox /bin/sh ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:1","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"基本命令 docker run -d -P \\ --rm \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ --network my-net \\ nginx:alpine docker run -d -P --rm --name web --mount type=bind,source=D:\\src\\webapp12345free,target=/usr/share/nginx/html,readonly --network my-net nginx:alpine -P 随机映射暴露端口，使用-p 80:80 指定端口 --rm 容器停止后自动删除容器 --name 指定容器别名 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"从 Container 拷贝文件到宿主机 # 使用 cp 命令 docker cp f0e212661cd5:/usr/local/etc/janus ./test ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:4:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"导出导入镜像 导出镜像 # docker save -o 要保存的文件名 要保存的镜像 docker save -o test.tar fengrui358/puppeteer_dotnet:aspnetcore5.0 导入镜像 # docker load --input 文件 docker load -i test.tar ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:5:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"docker 文件挂载 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"docker run 文件挂载 # Windows 下绝对路径目录 docker run --rm -it -v C:/test_docker_dir:/test_docker_dir busybox /bin/sh # Linux 下绝对路径目录 docker run --rm -it -v /home/ubuntu/test_docker_dir:/test_docker_dir busybox /bin/sh # Windows 下绝对路径文件 docker run --rm -it -v C:/test_docker_dir/file.txt:/test_docker_dir/file.txt busybox /bin/sh # Linux 绝对路径文件 docker run --rm -it -v /home/ubuntu/test_docker_dir/file.txt:/test_docker_dir/file.txt busybox /bin/sh # 相对路径目录 docker run --rm -it -v ${PWD}/test_docker_dir:/test_docker_dir busybox /bin/sh # Windows 下相对路径文件 docker run --rm -it -v ${PWD}/test_docker_dir/file.txt:/test_docker_dir/file.txt busybox /bin/sh ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:1","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"docker compose 文件挂载 version: '3' services: srs: image: busybox volumes: - ./test_docker_dir:/test_docker_dir - ./test_docker_dir/file.txt:/test_docker_dir2/file.txt command: ping baidu.com ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:2","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"常用 Docker 镜像 ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:0","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"postgres docker run -d --name er-db --rm -e POSTGRES_PASSWORD=1234 -v /home/free/datadir:/var/lib/postgresql/data -p 25435:5432 postgres:alpine ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:1","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"rabbitmq docker run -d --name er-mq --network er-network --rm -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_VHOST=er -e RABBITMQ_DEFAULT_USER=eruser -e RABBITMQ_DEFAULT_PASS=abc123 rabbitmq:management ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:2","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"Docker Ui Mananger portainer https://www.portainer.io/ docker volume create portainer_data docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer Seagull docker run -d -p 10086:10086 -v /var/run/docker.sock:/var/run/docker.sock tobegit3hub/seagull ","date":"2021-02-18","objectID":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:3","tags":["docker"],"title":"Docker 基本命令","uri":"/docker-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["docker"],"content":"npm ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:1:0","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["docker"],"content":"使用 nrm 管理 registry 地址 下载 nrm npm install -g nrm 添加 registry 地址 nrm add npm https://registry.npmjs.org nrm add taobao https://registry.npm.taobao.org 切换 npm registry 地址 nrm use taobao nrm use npm ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:1:1","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["docker"],"content":"docker 在 /etc/docker/daemon.json 中写入以下配置 { \"registry-mirrors\": [ \"https://mirror.ccs.tencentyun.com\", \"https://registry.cn-hangzhou.aliyuncs.com\", \"https://registry.docker-cn.com\", \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ] } 修改完成后重启服务 sudo systemctl daemon-reload sudo systemctl restart docker 参考：https://github.com/yeasy/docker_practice/blob/master/install/mirror.md ","date":"2021-02-12","objectID":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/:2:0","tags":["docker","deploy","resource"],"title":"Docker 国内源地址","uri":"/docker-%E5%9B%BD%E5%86%85%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"categories":["vuejs"],"content":"计算属性和方法的区别 计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，如下示例，因为 Date.now() 不是响应式依赖，所以下面的计算属性不再更新： computed: { now: function () { return Date.now() } } 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:1:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"计算属性和侦听属性的区别 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，通常更好的做法是使用计算属性而不是命令式的 watch 回调。 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:2:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"组件 组件的 data 属性需要是个函数，只有是个函数每个组件实例才可以维护一份被返回的对象的独立的拷贝，如果不是函数所有组件都共享同样的数据。 模板必须位于一个根元素节点下。 prop 可以设置一个带校验规则的对象，包含类型和默认值以及自定义的校验规则。 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:3:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["vuejs"],"content":"命名规范 属性名推荐使用 camelCase 命名规范 事件名推荐使用 kebab-case 命名规范 ","date":"2020-11-15","objectID":"/vuejs-%E7%AC%94%E8%AE%B0/:4:0","tags":["vuejs"],"title":"Vuejs 笔记","uri":"/vuejs-%E7%AC%94%E8%AE%B0/"},{"categories":["i18n"],"content":"夏令时切换场景 在有些国家会存在夏令时切换的情况，当这种情况出现时会凭空的多出或少去一个小时，这种情况我们的程序是如何处理？又是如何计算时常的呢？ 我们以墨西哥城的时间为例： 墨西哥城的时间 在 2020 年的 4 月 5 日的凌晨 3 点，会进入夏令时，时间会向前调一个小时，也就是说墨西哥城不会存在 2020 年 4 月 5 日 2 点到 2020 年 4 月 5 日 2 点 59 分的任何时间值。 ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:1:0","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["i18n"],"content":"消失的一个小时 下面我们用代码验证一下这个猜想 ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:2:0","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["i18n"],"content":"C# var miss1 = new DateTime(2020, 4, 25, 2, 0, 0, DateTimeKind.Local); var miss2 = new DateTime(2020, 4, 25, 2, 59, 59, DateTimeKind.Local); 这两个时间都正常生成成功 （未完待续…） ","date":"2020-11-03","objectID":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/:2:1","tags":["dotnet","i18n"],"title":"夏令时切换时间如何计算","uri":"/%E5%A4%8F%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97/"},{"categories":["deploy"],"content":"让 .netCore 2.0 的测试在 Azure DevOps 中正确运行需要注意几个地方 要增加 .netCore 的测试程序集目录； img 设置 Speceific location:C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\Common7\\IDE\\Extensions\\TestPlatform 设置 Other console options:/Framework:\".NETCoreApp,Version=v2.0\" img 默认配置会包含 xunit（我是使用的 xunit）的测试程序集，这个是不需要的，会导致测试过程报错，需要将其排除。 img ","date":"2020-10-21","objectID":"/azure-devops-%E8%B8%A9%E5%9D%91/:1:0","tags":["deploy"],"title":"Azure DevOps 踩坑","uri":"/azure-devops-%E8%B8%A9%E5%9D%91/"},{"categories":["deploy"],"content":"将程序集打包发布到 Nuget 并支持远程调试 程序集的项目文件需要加入打包相关配置： \u003c!-- Optional: Publish the repository URL in the built .nupkg (in the NuSpec \u003cRepository\u003e element) --\u003e \u003cPublishRepositoryUrl\u003etrue\u003c/PublishRepositoryUrl\u003e \u003c!-- Optional: Embed source files that are not tracked by the source control manager in the PDB --\u003e \u003cEmbedUntrackedSources\u003efalse\u003c/EmbedUntrackedSources\u003e \u003c!-- Optional: Build symbol package (.snupkg) to distribute the PDB containing Source Link --\u003e \u003cIncludeSymbols\u003etrue\u003c/IncludeSymbols\u003e \u003cSymbolPackageFormat\u003esnupkg\u003c/SymbolPackageFormat\u003e \u003cPackageLicenseExpression\u003eMIT\u003c/PackageLicenseExpression\u003e 特别是 License 节点，在本地 push 的时候不会出问题，在 Azure DevOps 环境下 Push 没有这个会出问题，不能够远程调试。 引入 SourceLink 程序集，下面是以代码提交到 GitHub 为例： \u003cItemGroup\u003e \u003cPackageReference Include=\"Microsoft.SourceLink.GitHub\" Version=\"1.0.0\" PrivateAssets=\"All\" /\u003e \u003c/ItemGroup\u003e 其他平台对应的 lib 可参考 https://github.com/dotnet/sourcelink 然后将程序集 push 到 nuget.org 时也会同时将 snupkg 文件 push 到符号服务器 要使用远程调试需要对 Visual Studio 做一些配置 img img ","date":"2020-10-21","objectID":"/azure-devops-%E8%B8%A9%E5%9D%91/:2:0","tags":["deploy"],"title":"Azure DevOps 踩坑","uri":"/azure-devops-%E8%B8%A9%E5%9D%91/"},{"categories":["router"],"content":"路由器型号，华硕 AC3100 梅林固件下载地址：https://www.asuswrt-merlin.net/download 具体下载地址格式：https://tenet.dl.sourceforge.net/project/asuswrt-merlin/RT-AC3100/Release/RT-AC3100_384.19_0.zip KoolShare 改版固件（带软件中心）：https://firmware.koolshare.cn/ AC3100（armv7 架构）梅林改下载地址：https://koolshare.cn/thread-164857-1-1.html SS 下载地址：https://github.com/hq450/fancyss_history_package ML 改的固件中的软件中心已经屏蔽了 ss 的离线安装，于是使用手动安装方式： 使用命令拷贝对应的文件到路由器 scp -P 45 E:\\Download\\shadowsocks.tar.gz admin@192.168.1.1:/tmp 具体命令如下： cd /tmp wget –no-check-certificate https://raw.githubusercontent.com/koolshare/koolshare.github.io/acelan_softcenter_ui/shadowsocks/shadowsocks.tar.gz tar -zxvf /tmp/shadowsocks.tar.gz chmod +x /tmp/shadowsocks/install.sh sh /tmp/shadowsocks/install.sh ","date":"2020-10-19","objectID":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/:0:0","tags":["router","deploy"],"title":"华硕路由器梅林固件设置","uri":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/"},{"categories":["router"],"content":"最新版 win10 访问路由器 USB 共享 需要设置注册表\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters \"AllowInsecureGuestAuth\"=dword:1 参考链接：https://huyangjia.com/merlin-firmware-installation-ss-plug-in-tutorial.html ","date":"2020-10-19","objectID":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/:1:0","tags":["router","deploy"],"title":"华硕路由器梅林固件设置","uri":"/%E5%8D%8E%E7%A1%95%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE/"},{"categories":["javascript"],"content":"类库 lodash：是一个通过 Lodash 限制操作频率的函数。 axios: Ajax 库。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"代码片段 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"查看对象类型 使用 Object.prototype.toString 方法，通过第二个参数返回的构造函数判断对象类型 Object.prototype.toString.call(2); // \"[object Number]\" Object.prototype.toString.call(\"\"); // \"[object String]\" Object.prototype.toString.call(true); // \"[object Boolean]\" Object.prototype.toString.call(undefined); // \"[object Undefined]\" Object.prototype.toString.call(null); // \"[object Null]\" Object.prototype.toString.call(Math); // \"[object Math]\" Object.prototype.toString.call({}); // \"[object Object]\" Object.prototype.toString.call([]); // \"[object Array]\" ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:1","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"JavaScript 对象的元属性 { value: 123, writable: false, enumerable: true, configurable: false, get: undefined, set: undefined } ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:2","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"将类似于数组的对象转换为数组 slice() 方法的一个重要应用，是将类似数组的对象转为真正的数组。 Array.prototype.slice.call({ 0: \"a\", 1: \"b\", length: 2 }); // ['a', 'b'] Array.prototype.slice.call(document.querySelectorAll(\"div\")); Array.prototype.slice.call(arguments); ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:3","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"构造函数 为了保证构造函数必须与 new 命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上 use strict。这样的话，一旦忘了使用 new 命令，直接调用构造函数就会报错。 function Fubar(foo, bar) { \"use strict\"; this._foo = foo; this._bar = bar; } Fubar(); // TypeError: Cannot set property '_foo' of undefined 另一个解决办法，构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象。 function Fubar(foo, bar) { if (!(this instanceof Fubar)) { return new Fubar(foo, bar); } this._foo = foo; this._bar = bar; } Fubar(1, 2)._foo( // 1 new Fubar(1, 2) )._foo; // 1 如果构造函数内部有 return 语句，而且 return 后面跟着一个对象，new 命令会返回 return 语句指定的对象；否则，就会不管 return 语句，返回 this 对象。 函数内部可以使用 new.target 属性。如果当前函数是 new 命令调用，new.target 指向当前函数，否则为 undefined。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:4","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"防止脚本篡改 为了防止攻击者篡改外部脚本，script 标签允许设置一个 integrity 属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。 \u003cscript src=\"/assets/application.js\" integrity=\"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=\" \u003e\u003c/script\u003e ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:5","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"使用正则表达式提取解构值 用正则表达式的 exec() 方法匹配字符串会返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串——如果不需要的话。 function parseProtocol(url) { var parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url); if (!parsedURL) { return false; } console.log(parsedURL); // [\"https://developer.mozilla.org/en-US/Web/JavaScript\", \"https\", \"developer.mozilla.org\", \"en-US/Web/JavaScript\"] var [, protocol, fullhost, fullpath] = parsedURL; return protocol; } console.log( parseProtocol(\"https://developer.mozilla.org/en-US/Web/JavaScript\") ); // \"https\" ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:6","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"匹配 Unicode 属性 // 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test('²³¹¼½¾') // true regex.test('㉛㉜㉝') // true regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true // 匹配所有空格 \\p{White_Space} // 匹配各种文字的所有字母，等同于 Unicode 版的 \\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配 Emoji /\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true //解构赋值 let {groups: {one, two}} = /^(?\u003cone\u003e.*):(?\u003ctwo\u003e.*)$/u.exec('foo:bar'); one // foo two // bar ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:7","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["javascript"],"content":"尾递归优化技巧，蹦床函数（trampoline） function trampoline(f) { while (f \u0026\u0026 f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要 f 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y \u003e 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum 函数的每次执行，都会返回自身的另一个版本。现在，使用蹦床函数执行 sum，就不会发生调用栈溢出。 ","date":"2020-09-18","objectID":"/javascript-%E7%AC%94%E8%AE%B0/:2:8","tags":["javascript"],"title":"Javascript 笔记","uri":"/javascript-%E7%AC%94%E8%AE%B0/"},{"categories":["package"],"content":" 客户端下载，nuget.exe：https://www.nuget.org/downloads NuGetPackageExplorer（可视化的创建包管理器）：https://github.com/NuGetPackageExplorer/NuGetPackageExplorer nuspec.xsd 创建包的文件清单的 XML 架构文件：https://github.com/NuGet/NuGet.Client/blob/dev/src/NuGet.Core/NuGet.Packaging/compiler/resources/nuspec.xsd .nuspec 引用相关资料：https://docs.microsoft.com/zh-cn/nuget/schema/nuspec#replacement-tokens 依赖版本描述语义：https://docs.microsoft.com/zh-cn/nuget/reference/package-versioning#pre-release-versions 转换源代码和配置文件相关：https://docs.microsoft.com/zh-cn/nuget/create-packages/source-and-config-file-transformations PowerShell 参考：https://docs.microsoft.com/zh-cn/nuget/tools/powershell-reference ","date":"2020-07-15","objectID":"/nuget-%E8%B5%84%E6%BA%90/:0:0","tags":["dotnet","nuget","package"],"title":"NuGet 资源","uri":"/nuget-%E8%B5%84%E6%BA%90/"},{"categories":["dotnet"],"content":"RabbitMQ，提供负载均衡的消息队列功能，自动化的将消息按规则分配到不同消费者身上。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:0:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"安装 RabbitMQ 安装非常简单，首先安装 Erlang，然后安装服务端程序https://www.rabbitmq.com/install-windows.html。 安装完毕后启动可视化管理功能，在开始菜单中找到 RabbitMQ Server，运行 RabbitMQ Command Prompt，然后在控制台中执行两条命令： rabbitmq-plugins enable rabbitmq_management 然后通过链接地址：http://localhost:15672 即可在本地访问管理界面，默认本地访问的用户名和密码均为：guest。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"入门 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"ConnectionFactory Socket 链接的创建工厂，除了HostName、VirtualHost、UserName、Password几个常见参数外，还有个比较重要的自动重连参数：AutomaticRecoveryEnabled，该参数默认为false，与之相关的还有一个自动重连的尝试间隔NetworkRecoveryInterval，该参数默认值为 5 秒。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:1","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"IConnection 通过 ConnectionFactory 的 CreateConnection 可以构造一个 IConnection 的接口，一个这个接口的实例就代表了一个真正的 TCP Socket 链接。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:2","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"IModel 通过 IConnection 的 CreateModel 方法创建，抽象的信息通道，然后通过通道可创建和使用队列、交换机。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:3","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"EventingBasicConsumer 实例化一个事件消费者，构造时传入 IModel，然后可以异步订阅消息。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:4","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"BasicPublish 通过 IModel 的 BasicPublish 方法可以向交换机发送信息并指定路由标识。 ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:5","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Tutorials https://github.com/rabbitmq/rabbitmq-tutorials ","date":"2020-06-11","objectID":"/rabbitmq-%E7%AC%94%E8%AE%B0/:2:6","tags":["dotnet","rabbitmq"],"title":"RabbitMQ 笔记","uri":"/rabbitmq-%E7%AC%94%E8%AE%B0/"},{"categories":["resource"],"content":"因受国内的环境影响，导致了很多速度起不来，所以需要安装国内镜像。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:0:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"配置 NPM 的淘宝镜像源加速 打开 poweshell 或 cmd 工具，输入以下命令： npm config set registry https://registry.npm.taobao.org npm config set disturl https://npm.taobao.org/dist npm config set electron_mirror https://npm.taobao.org/mirrors/electron/ npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ 然后输入命令 npm get registry 得到返回结果为 https://registry.npm.taobao.org/ 说明注册成功。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:1:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"windows 下 Yarn 安装与使用 如果你还没有安装 Yarn，通过访问 https://classic.yarnpkg.com/latest.msi，下载安装包。双击安装后，输入命令 yarn -v 返回版本号 1.22.4 即表示成功。 ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:2:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["resource"],"content":"Yarn 注册淘宝镜像源加速 打开 poweshell 或 cmd 工具，输入以下命令： yarn config set registry https://registry.npm.taobao.org -g yarn config set disturl https://npm.taobao.org/dist -g yarn config set electron_mirror https://npm.taobao.org/mirrors/electron/ -g yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g yarn config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -g yarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -g yarn config set operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -g yarn config set fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g 然后输入命令，查看当前地址源： yarn config get registry 得到返回结果为 https://registry.npm.taobao.org/ 说明注册成功。 本文作为资源记录，转载自：https://mp.weixin.qq.com/s/3LQVKnEY4Fk7UTtMBN5YxA ","date":"2020-05-12","objectID":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/:3:0","tags":["npm","resource","package"],"title":"NPM 和 Yarn 使用国内淘宝镜像源提升各依赖安装速度","uri":"/npm-%E5%92%8C-yarn-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E6%8F%90%E5%8D%87%E5%90%84%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6/"},{"categories":["dotnet"],"content":"今天测试人员报公司的 WPF 程序启动崩溃，下面记录这个问题的跟踪流程。 首先排除是否为发版问题，向测试要了测试环境的程序，运行奔溃，观察日志报 System.OutOfMemoryException； 启用本地 Debug 程序运行，发现内存快速增长直到进程崩溃； 启动 Visual Studio 的性能跟踪工具，跟踪内存增长，由于进程一启动内存就快速增长来不及做快照，故在代码中做了启动延时处理。拍下快照，对比内存快照，发现托管内存没有增加，判断为非托管内存溢出； 由于这是个启动就能出现的问题，启动代码也不多，就尝试注释一些代码来缩小问题范围，当注释掉 CefSharp 的初始化代码后程序就正常了，进而判断内存溢出出现在 CefSharp 内部； 回退代码到一周前，启动程序后问题照旧，到这时就很诡异了，因为最近这个程序我们在开发环境下都是经常运行的，从来没出现过这个一启动就能发现的问题，而今天一周前的代码都出现了问题，这就排除是代码修改造成的； 初步判断是环境问题造成，这时候注意到公司的网络不能访问 google 了，之前公司是提供了梯子的，只要开启自动检测代理就能“出国”。我刚开始猜测 Cef 是 google 的嵌入式浏览器，难道它要访问 google 的服务？我首先尝试禁用网卡，程序奇迹般的正常了，虽然业务不可用，但是内存不涨了，证明它不需要访问 google 的服务。然后我关掉代理自动检测，程序也完全正常了。 总结一下，我没有去搜索这个问题，因为不太好描述，只能大概猜测这个问题的原因：Cef 是嵌入的一个独立浏览器进程，和我们程序进程通讯应该通过了网卡，现在公司代理有问题，导致通讯出了问题，非托管内存就溢出了。但这个问题只出现在代理故障的情况，代理正常、关闭代理甚至关闭网卡 Cef 都是正常的，于是猜测是不是公司代理配置出现了什么回路之类的导致程序通信消耗内存暴增。整个问题的追踪很有意思，耗时大概两个小时，这还需要一定经验和灵光乍现才能想到网卡设备这个层面。 ","date":"2020-04-16","objectID":"/cefsharp-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/:0:0","tags":["dotnet","wpf","cef"],"title":"CefSharp 内存溢出问题排查","uri":"/cefsharp-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"categories":["dotnet"],"content":"添加 AnyCPU 支持 需要在项目配置文件的第一个 \u003cPropertyGroup\u003e 节点中添加 \u003cCefSharpAnyCpuSupport\u003etrue\u003c/CefSharpAnyCpuSupport\u003e WPF 启动时代码如下： public partial class App : Application { public App() { //Add Custom assembly resolver AppDomain.CurrentDomain.AssemblyResolve += Resolver; //Any CefSharp references have to be in another method with NonInlining // attribute so the assembly rolver has time to do it's thing. InitializeCefSharp(); } [MethodImpl(MethodImplOptions.NoInlining)] private static void InitializeCefSharp() { var settings = new CefSettings(); // Set BrowserSubProcessPath based on app bitness at runtime settings.BrowserSubprocessPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, Environment.Is64BitProcess ? \"x64\" : \"x86\", \"CefSharp.BrowserSubprocess.exe\"); // Make sure you set performDependencyCheck false Cef.Initialize(settings, performDependencyCheck: false, browserProcessHandler: null); } // Will attempt to load missing assembly from either x86 or x64 subdir // Required by CefSharp to load the unmanaged dependencies when running using AnyCPU private static Assembly Resolver(object sender, ResolveEventArgs args) { if (args.Name.StartsWith(\"CefSharp\")) { string assemblyName = args.Name.Split(new[] { ',' }, 2)[0] + \".dll\"; string archSpecificPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, Environment.Is64BitProcess ? \"x64\" : \"x86\", assemblyName); return File.Exists(archSpecificPath) ? Assembly.LoadFile(archSpecificPath) : null; } return null; } } 引入 Cef 后程序体积增加 347 MB（x64 和 x86 各占一半） win7 下要正常使用 Cef 安装 https://www.microsoft.com/en-us/download/details.aspx?id=48145 参考 https://www.shuzhiduo.com/A/n2d9QqgVdD/ win8 参考 https://www.shuzhiduo.com/A/1O5ElwVGJ7/ ","date":"2020-04-08","objectID":"/wpf-%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-cefsharp/:1:0","tags":["dotnet","wpf","cef"],"title":"WPF 程序使用 CefSharp","uri":"/wpf-%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-cefsharp/"},{"categories":["wpf"],"content":"WPF 桌面程序中使用图片有多种方式，他们具有一些如下特点: 特点/类型 PNG SVG Path Font IconFont 性能 好 差 中 好 中 改变颜色 不支持 不支持 支持 支持 支持 改变大小 不支持 支持 支持 支持（不友好） 支持 多色彩支持 支持 支持 不支持 不支持 不支持 ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:0:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"PNG 位图是使用最多的一种方式，也是 WPF 原生 Image 控件支持的一种方式，性能是几种方式当中最好的，不过它的缺点是不支持改变图片颜色和大小（改变大小后会有模糊和锯齿），当一个项目大了之后项目中会有很多形状类似，但可能大小和颜色有细微差别的图片，会造成项目难以管理。（下图是性能对比，是在一个窗口中初始化 3000 个控件的耗时） PNG ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:1:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"SVG SVG 是常用的一种矢量图，浏览器对 SVG 也是可以直接支持。SVG 矢量图的好处是美工可以直接出图，程序员可以不用再进行二次转换，而且矢量图可以做出各种彩色的复杂图形。但是 WPF 对 SVG 却不能原生支持，不过我们还是能比较轻松地在网上找到很多现成的解决方案，如图，是 SVG 的性能。 SVG ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:2:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"Path Path 是 WPF 中描述矢量图的常用方式，著名的 WPF 开源项目 MahApps.Metro 里的有一个使用矢量图的控件 Metro.IconPacks 就是对 Path 的封装，下面是该控件的性能。 Path ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:3:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"IconFont 目前 Web 前端中用的非常多的一种矢量图片就是文字，经过测试，它的性能介于接近最快的 PNG，经过封装以后它的易用性可以达到 MahApps.Metro 的水平，并且它指定的高宽参数能够最贴近 UI 人员的设计意图。并且我写了一个小工具可以从 https://www.iconfont.cn/ 下载项目图标，直接转换为程序可用的强类型引用，使代码可以很方便的使用 .ttf 字体文件中的字体作为图标。 ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:4:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["wpf"],"content":"资源路径如下 测试工具地址：https://github.com/fengrui358/WPFLabs/tree/master/WpfLabs/WpfLabs/ImagePerformanceDemo 图标转换工具地址：https://github.com/fengrui358/IconFontForWPF ","date":"2020-03-13","objectID":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/:5:0","tags":["wpf","ui"],"title":"搭配 IconFont 在 WPF 中使用文字图片","uri":"/%E6%90%AD%E9%85%8D-iconfont-%E5%9C%A8-wpf-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87/"},{"categories":["dotnet"],"content":"本文基于 Automapper 9.0.0 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"诊断 Automapper 的属性映射过程 var cfg = new MapperConfigurationExpression(); cfg.CreateMap\u003cTypeB, TypeA\u003e(); var configuration = new MapperConfiguration(cfg); var executionPlan = configuration.BuildExecutionPlan(typeof(TypeB), typeof(TypeA)); 最关键的一行代码 var executionPlan = configuration.BuildExecutionPlan(typeof(TypeB), typeof(TypeA));，此时查看 executionPlan 可以看到它对应的表达式树解析，看到属性如何映射。这里有个小技巧，安装 Visual Studio 插件 ReadableExpressions VS extension 可以更清晰的看到表达式树解析。需要注意应该在正式发布时移除所有的调试代码。 参考http://docs.automapper.org/en/stable/Understanding-your-mapping.html ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"自动映射属性 Automapper 会自动按照属性名去匹配映射关系，在默认映射中有以下一些特点： 不会区分属性名大小写，只要名称一样，大小写不一致也能够转换； 不会严格要求类型，字符串数值之间可以互相转换； 如果没匹配对应的属性，会继续寻找带 Get 前缀的方法名，也可以自动对目标类型进行 PascalCase 约定的 分词查找，按照分词的顺序可以在源类型中深度查找内部对象。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"类的成员对象向外映射 类型映射时想要映射的是 Source 类型的内部成员对象时，创建映射时需要加 IncludeMembers。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"配置校验，测试映射关系 Automapper 的映射是基于约定的，并不是强类型之间的手动映射，一个典型的应用场景是创建好映射之后，过了一段时间可能属性名变了，就会造成潜在的 Bug，这时候就需要使用配置校验 Configuration Validation，如下： var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Destination\u003e()); configuration.AssertConfigurationIsValid(); 默认的校验规则是需要检查目标的每个属性都需要在来源中有映射，否则抛出异常。 有两种方式方式修改默认的校验规则： 使用 Ignore()，var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Destination\u003e().ForMember(dest =\u003e dest.SomeValuefff, opt =\u003e opt.Ignore())); CreateMap 的时候修改校验规则，使用 MemberList.Source 或 MemberList.None ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"集合映射 如果要映射集合只需要映射集合对应的元素类型，支持的集合映射类型如下： IEnumerable IEnumerable\u003cT\u003e ICollection ICollection\u003cT\u003e IList IList\u003cT\u003e List\u003cT\u003e Arrays 如果要映射到一个已存在的集合，目标集合首先会被清空，具体详见 AutoMapper.Collection 如果源的属性里有集合对象，并且属性为空，那么当它映射到目标时，会把属性映射为空集合，这一点符合 C# 关于集合的定义，数组、列表、集合、字典和 IEnumerables 永远不应该为 null。在配置映射器时，可以通过将 AllowNullCollections 属性设置为 true 来更改此行为。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"全局类型转换 Type Converters 在创建配置时使用 ConvertUsing，这个配置是全局的，只需要调用一次，它有以下三种重载方式： void ConvertUsing(Func\u003cTSource, TDestination\u003e mappingFunction); void ConvertUsing(ITypeConverter\u003cTSource, TDestination\u003e converter); void ConvertUsing\u003cTTypeConverter\u003e() where TTypeConverter : ITypeConverter\u003cTSource, TDestination\u003e; ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"需要自定义源到目标之间的转换逻辑 Value Resolvers 当出现需要自定义转换逻辑时，主要使用以下接口： public interface IValueResolver\u003cin TSource, in TDestination, TDestMember\u003e { TDestMember Resolve(TSource source, TDestination destination, TDestMember destMember, ResolutionContext context); } 使用 IValueResolver 接口有以下三种方式： MapFrom\u003cTValueResolver\u003e MapFrom(typeof(CustomValueResolver)) MapFrom(aValueResolverInstance) 除以上之外还可以继承 IMemberValueResolver 接口，这个接口比上面那个多了来源属性的指定。 ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"解析条件 如果我们指定了属性成员的映射，那在正式转换时可能会引发异常，这时候可以进行前置条件判断。 public class SourceClass { public string Value { get; set; } } public class TargetClass { public int ValueLength { get; set; } } // ... var source = new SourceClass { Value = null }; var target = new TargetClass; CreateMap\u003cSourceClass, TargetClass\u003e() .ForMember(d =\u003e d.ValueLength, o =\u003e o.MapFrom(s =\u003e s.Value.Length)) .ForAllMembers(o =\u003e o.Condition((src, dest, value) =\u003e value != null)); .ForMember(d =\u003e d.ValueLength, o =\u003e o.MapFrom(s =\u003e s != null ? s.Value.Length : 0)) ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Value Converters 介于 Type Converters 和 Value Resolvers 之间的值转换方式： Type converter = Func\u003cTSource, TDestination, TDestination\u003e Value resolver = Func\u003cTSource, TDestination, TDestinationMember\u003e Member value resolver = Func\u003cTSource, TDestination, TSourceMember, TDestinationMember\u003e Value converter = Func\u003cTSourceMember, TDestinationMember\u003e 在成员级别配置该转换器 public class CurrencyFormatter : IValueConverter\u003cdecimal, string\u003e { public string Convert(decimal source) =\u003e source.ToString(\"c\"); } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cOrder, OrderDto\u003e() .ForMember(d =\u003e d.Amount, opt =\u003e opt.ConvertUsing(new CurrencyFormatter())); cfg.CreateMap\u003cOrderLineItem, OrderLineItemDto\u003e() .ForMember(d =\u003e d.Total, opt =\u003e opt.ConvertUsing(new CurrencyFormatter())); }); 如果属性的名称不能匹配，使用以下方式 public class CurrencyFormatter : IValueConverter\u003cdecimal, string\u003e { public string Convert(decimal source) =\u003e source.ToString(\"c\"); } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cOrder, OrderDto\u003e() .ForMember(d =\u003e d.Amount, opt =\u003e opt.ConvertUsing(new CurrencyFormatter(), src =\u003e src.OrderAmount)); cfg.CreateMap\u003cOrderLineItem, OrderLineItemDto\u003e() .ForMember(d =\u003e d.Total, opt =\u003e opt.ConvertUsing(new CurrencyFormatter(), src =\u003e src.LITotal)); }); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"值转换 在值转换前判断是否应用了值转换器，可以在以下地方使用值转换器： Globally Profile Map Member var configuration = new MapperConfiguration(cfg =\u003e { cfg.ValueTransformers.Add\u003cstring\u003e(val =\u003e val + \"!!!\"); }); var source = new Source { Value = \"Hello\" }; var dest = mapper.Map\u003cDest\u003e(source); dest.Value.ShouldBe(\"Hello!!!\"); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"Null 转换 如果来源值为空，可以使用空转换器来给目标属性赋值，而不是使用源值 var config = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, Dest\u003e() .ForMember(destination =\u003e destination.Value, opt =\u003e opt.NullSubstitute(\"Other Value\"))); var source = new Source { Value = null }; var mapper = config.CreateMapper(); var dest = mapper.Map\u003cSource, Dest\u003e(source); dest.Value.ShouldEqual(\"Other Value\"); source.Value = \"Not null\"; dest = mapper.Map\u003cSource, Dest\u003e(source); dest.Value.ShouldEqual(\"Not null\"); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"映射前后逻辑处理 偶尔需要在映射时进行一些逻辑处理，可使用如下方式： var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cSource, Dest\u003e() .BeforeMap((src, dest) =\u003e src.Value = src.Value + 10) .AfterMap((src, dest) =\u003e dest.Name = \"John\"); }); 或者继承接口 IMappingAction： public class NameMeJohnAction : IMappingAction\u003cSomePersonObject, SomeOtherPersonObject\u003e { public void Process(SomePersonObject source, SomeOtherPersonObject destination, ResolutionContext context) { destination.Name = \"John\"; } } var configuration = new MapperConfiguration(cfg =\u003e { cfg.CreateMap\u003cSomePersonObject, SomeOtherPersonObject\u003e() .AfterMap\u003cNameMeJohnAction\u003e(); }); ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["dotnet"],"content":"构造函数映射 如果目标类型没有默认的构造函数，Automapper 支持根据构造函数的形参名称来自动匹配源属性。 public class Source { public int Value { get; set; } } public class SourceDto { public SourceDto(int value) { _value = value; } private int _value; public int Value { get { return _value; } } } var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, SourceDto\u003e()); 如果构造函数的参数名称无法自动匹配，可以使用 ForCtorParam 来手动指定 public class Source { public int Value { get; set; } } public class SourceDto { public SourceDto(int valueParamSomeOtherName) { _value = valueParamSomeOtherName; } private int _value; public int Value { get { return _value; } } } var configuration = new MapperConfiguration(cfg =\u003e cfg.CreateMap\u003cSource, SourceDto\u003e() .ForCtorParam(\"valueParamSomeOtherName\", opt =\u003e opt.MapFrom(src =\u003e src.Value)) ); 如果要禁用构造函数映射 var configuration = new MapperConfiguration(cfg =\u003e cfg.DisableConstructorMapping()); 也可以选择要调用的目标构造函数 // don't map private constructors var configuration = new MapperConfiguration(cfg =\u003e cfg.ShouldUseConstructor = ci =\u003e !ci.IsPrivate); 参考：http://docs.automapper.org/en/stable/index.html ","date":"2020-01-28","objectID":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["dotnet","mapper"],"title":"Automapper 学习笔记","uri":"/automapper-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["css"],"content":"文本与段落 加载本地字体，通常按照从特殊到一般 font-family: Arial, 'Microsoft Yahei', sans-serif; 加载 web 字体 @font-face { font-family: 'webfont'; src: url('webfont.woff'); } font-family: 'webfont', Arial, 'Microsoft Yahei', sans-serif; 颜色 color: #077f3c; 大小 font-size: 28px; 字符间距 letter-spacing: 4px; 文本方向 writing-mode: vertical-rl; text-orientation: mixed; 文本样式 text-decoration: underline line-through; 行间距 line-height: 36px; 缩进 text-indent: 2em; 折行 white-space: nowrap; 省略 white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 对齐 text-align: justify; 设置背景颜色 background-color: #8be5ac; 加载背景图片 background-image: url(./bg.jpg); 调整背景尺寸 background-size: 50px; 调整背景填充 background-repeat: no-repeat; 调整背景位置 雪碧图通常使用该属性实现 background-position: center center; 调整背景拉伸 background-size: contain; /* 充满容器，可能会留白 */ background-size: cover; /* 充满容器，可能会裁剪 */ ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:1:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["css"],"content":"外发光悬空阴影 box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23); 外发光悬空阴影 ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:2:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["css"],"content":"HSL 定义 HSL 颜色 色相（H） 是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。 饱和度（S） 是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100% 的数值。 亮度（L） ，取 0-100%，增加亮度，颜色会向白色变化；减少亮度，颜色会向黑色变化。 https://www.runoob.com/cssref/func-hsl.html 参考：https://www.bilibili.com/video/BV1654y1m76w?p=1\u0026share_medium=iphone\u0026share_plat=ios\u0026share_source=COPY\u0026share_tag=s_i×tamp=1598287257\u0026unique_k=KP2sHN ","date":"2019-11-15","objectID":"/css-%E8%B5%84%E6%BA%90/:3:0","tags":["css","resource"],"title":"CSS 资源","uri":"/css-%E8%B5%84%E6%BA%90/"},{"categories":["ide"],"content":"专栏地址：https://time.geekbang.org/column/article/40098 ","date":"2019-10-13","objectID":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["ide","vscode"],"title":"Visual Studio Code 专栏学习笔记","uri":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"常用命令 打开命令面板：Ctrl+Shift+P F1 Cmd 窗口命令：Code，Code --help查看命令帮助，Cmd 命令加| Code -可直接将 Cmd 命令的结果输出到 VS Code 的一个页面中，方便后续操作 编辑操作： 删除当前行：Ctrl+Shift+K 剪切当前行：Ctrl+Shift+X 复制当前行：Ctrl+Shift+C 新起一行到下一行：Ctrl+Enter 新起一行到上一行：Ctrl+Shift+Enter 当前行向上\\下移动：Alt+↑\\↓ 向上\\下复制当前行：Alt+Shift+↑\\↓ 添加行注释：Ctrl+/ 添加块注释：Alt+Shift+A 代码格式化（需安装各个语言对应的插件）：Alt+Shift+F 选中段代码格式化：Ctrl+K Ctrl+F 光标回退到之前位置：Ctrl+U 在一个函数的括号中跳转：Ctrl+Shift+\\ 多光标：Ctrl+Alt+鼠标 Ctrl+Alt+↑\\↓ Ctrl+D Ctrl+D(选中重复的单词为他们生成多光标) Alt+Shift+I 展开文件列表：Ctrl+Tab 然后按住Ctrl 按下Tab即可在文件列表中切换 展开文件列表并搜索：Ctrl+P 在文件列表中按下Ctrl+Enter可在新窗口打开选中的文件 Ctrl+P+文件名+冒号+行号 可跳转到指定文件的指定行号 跳转到指定行号：Ctrl+G 在一个文件的类、方法中跳转：Ctrl+Shift+O Ctrl+Shift+O+冒号 可对当前文件中的符号进行分类 在多个文件中进行符号跳转：Ctrl+T 跳转到符号定义：Ctrl+F12 F12 跳转到符号引用：Shift+F12 鼠标操作：连续3次按下鼠标左键选中当前行 连续4次按下鼠标左键选中当前文档所有文本 选择行号可选中当前行 选中文本+Alt 移动光标可复制选中段 鼠标悬停+按住Ctrl 提示当前悬停位置的额外信息 触发建议：命令面板中输入\"Trigger Suggest\"，默认快捷键为Ctrl+Space，修改为Alt+Enter 跳转：跳转回上一次光标位置Alt+Left，跳转到下一次光标位置Alt+Right，可通过命令跳转到上一次编辑所在位置 粘贴：粘贴富文本Ctrl+V，粘贴纯文本Ctrl+Shift+V 选中当前行：Ctrl+I 自动补全： 函数签名预览：Ctrl+Space 函数参数预览：Ctrl+Shift+Space 自动补全：在设置中搜索Editor.Suggest可修改编辑推荐参数 快速修复：绿色波浪线上点击Ctrl+. 重构 重命名：F2 鼠标选中可提取成单独的函数 代码片段 在命令面板中配置代码片段：Configure User Snippets 输入代码片段中的prefix可提示代码片段，按Tab输出代码片段，再按Tab在占位符间切换，按Shift+Tab在占位符中反向切换。 代码片段占位符{1:label}，代码片段内置变量说明：https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables 代码折叠 折叠选中部分的括号：Ctrl+Shift+[ 递归折叠当前选中部分的括号：Ctrl+K Ctrl+[ 折叠所有可折叠的部分：Ctrl+K Ctrl+0 展开所有可展开的部分：Ctrl+K Ctrl+J 标记折叠，不同语言有不同的折叠方式，请参考：https://code.visualstudio.com/docs/editor/codebasics#_folding 折叠标记和展开标记的快捷键分别是：Ctrl+K Ctrl+8 Ctrl+K Ctrl+9 小地图相关设置：editor.minimap 面包屑相关设置：breadcrumbs.enabled 搜索 单文件搜索：Ctrl+F(鼠标切换到搜索框) F3(鼠标停留在文本编辑页面) Shift+F3(反向跳转) 搜索设置：Alt+C(切换大小写) Alt+W(切换全词匹配) Alt+R(切换正则搜索) 替换搜索：Ctrl+H Tab Shift+Tab(可在替换框中切换) 多文件搜索：Ctrl+Shift+F 编辑器设置 设置行号：editor.lineNumbers 渲染空格或制表符：editor.renderWhitespace 缩进竖线：editor.renderIndentGuides 行字符数量控制线：\"editor.rulers\": [20] 鼠标样式控制：editor.cursorBlinking editor.cursorStyle editor.cursorWidth 选中行高亮显示：editor.renderLineHighlight 编辑器制表符和空格设置：editor.detectIndentation editor.insertSpaces editor.tabSize 代码格式自动校正：editor.formatOnSave editor.formatOnType 自动保存控制：files.autoSave files.autoSaveDelay 设置新建文件的默认格式：files.defaultLanguage=markdown 调整自动推荐时间间隔：editor.quickSuggestionsDelay: 0 编辑器设置分类 光标渲染和多光标相关的设置：editor cursor 搜索相关的设置：editor find 字体相关的设置：editor font 代码格式化相关的设置：editor fotmat 自动补全、建议相关的设置：editor suggest 命令面板 命令历史记录：workbench.commandPalette.history 命令面板打开时保留之前的输入：workbench.commandPalette.preserveInput 多文件夹工作区 打开最近访问的文件或文件夹：Ctrl+R 终端 切换终端：Ctrl+` 创建新终端：Ctrl+Shift+` 终端配置：terminal.integrated 向终端运行指定命令：Run Active File In Active Terminal Run Selected Text In Active Terminal 工作流（WorkFlow） 自动运行任务：Run Task 配置任务：Configure Task https://code.visualstudio.com/docs/editor/tasks#_custom-tasks 脚本执行结果分析：https://marketplace.visualstudio.com/search?term=problem%20matcher\u0026target=VSCode\u0026category=All%20categories\u0026sortBy=Relevance 多行错误分析器https://code.visualstudio.com/docs/editor/tasks#_defining-a-multiline-problem-matcher 调试（Debug） 打开调试界面：Ctrl+Shift+D program 一般用于指定将要调试的文件。 stopOnEntry，当调试器启动后，是否在第一行代码处暂停代码的执行。这个属性非常方便，如果没有设置断点而代码执行非常快的话，我们就会像文章的最开头那样，代码调试一闪而过，而设置了 stopOnEntry 后，代码会自动在第一行停下来，然后我们就可以继续我们的代码调试了。 args 参数。相信你应该记得在前面任务系统配置的文章里，我已经说明了可以使用 args 来控制传入任务脚本的参数，同样的，我们也可以通过 args 来把参数传给将要被调试的代码。 env 环境变量。大部分调试器都使用它来控制调试进程的特殊环境变量。 cwd 控制调试程序的工作目录。 port 是调试时使用的端 27。 工作区 拆分编辑器：Ctrl+\\ Split Editor 在编辑器组中快速跳转：Ctrl+1 Ctrl+2 切换垂直 / 水平编辑器布局：Shift+Alt+0 Flip Editor Group Layout 专注模式：Ctrl+B Ctrl+J Toggle Activity Bar Visibility Toggle Status Bar Visibility Toggle Zen Mode Toggle Centered Layout 缩放：Ctrl+-/+ View:Rest Zoom 快捷键设置 打开快捷键设置：Open Keyboard Shortcuts 设置 KeyBindings.json：有三个主要属性，Key设置快捷键，Command对应的系统命令，When触发时机（详见:https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts，如果想解除某个快捷键，只需要在 Command 的最前面加上-就可以覆盖默认设置。 Json 支持 Json 是 VsCode 默认支持的语言，可通过Json Schemas对 Json 的语法进行校验和智能提示，样例如下： { \"json.schemas\": [ { \"fileMatch\": [\"/.myconfig\"], \"schema\": { \"type\": \"object\", \"properties\": { \"name\": { \"type\": \"string\",","date":"2019-10-13","objectID":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["ide","vscode"],"title":"Visual Studio Code 专栏学习笔记","uri":"/visual-studio-code-%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"主框架 隐藏、开启侧边栏：Ctrl+B 交互式演习场 Help -Interactive Playground 可以帮助学习 VS Code ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"编辑区分栏 创建一个新的分栏：Ctrl+\\ 关闭当前选中的分栏：Ctrl+W 在三个分栏间切换：Ctrl+1,2,3 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"资源管理器 移动选中文件后快速打开该文件到编辑区：Ctrl+Enter 快速搜索一个文件（执行其他命令）：Ctrl+P ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"配置编辑器 VS Code 给予了我们很灵活的配置项，可以通过 user settings 设置全局项，或通过 workspace settings 设置每一个项目或文件夹的配置。设置的值保存在一个 setting.json 文件中。 通过 Ctrl+Shift+P 打开命令输入栏，输入 user 然后按 Enter 可以编辑全局的用户 setting.json 文件。 通过 Ctrl+Shift+P 打开命令输入栏，输入 worksp 然后按 Enter 可以编辑项目或文件夹的 setting.json 文件。 当启动配置编辑时可在左边窗口看到 VS Code 的默认配置，我们要编辑的 setting.json 会放在右边窗口。从默认配置可以很方便的进行审查和复制。 完成配置编辑后，按下 Ctrl+S 保存更改，更改将会立即生效。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"保存和自动保存 默认情况下，VS Code 需要显示的进行保存操作，即按 Ctrl+S。 然而，我们也可以很轻松的开启自动保存，可通过配置进行定时触发保存或是等待焦点离开编辑器时自动保存。当自动保存开启后，就不再需要显示的进行文件保存。 要开启 Auto Save，需要打开 User Settings 或 Workspace Settings 找到相关配置项： files.autoSave：可以设置 off（默认值）来禁用自动保存，可以设置 afterDelay 来配置一个自动保存的延迟时间，也可以配置 onFocusChange 来当我们的焦点离开正在编辑的文件时自动保存。 files.autoSaveDelay：当 files.autoSave 配置为 afterDelay 时可指定自动保存延时的毫秒数。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"通过文件搜索 Ctrl+Shift+F 快速搜索当前打开的文件夹里的内容，单击搜索结果项可将它展示在编辑区。 TIP: 支持正则表达式搜索。 Ctrl+Shift+J 可打开搜索的高级设置，其中可以设置要包含或是要排除的文件。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"命令面板 通过快捷键 Ctrl+Shift+P 可快速的打开命令面板，在命令面板中我们可以访问 VS Code 的所有功能，包括快捷键设置和大多数通用操作。 命令面板还能执行一些其他常用的命令，如编辑器命令，打开文件，查找符号，快速浏览一个文件等，下面是一些常用的命令： Ctrl+P 可快速导航到一个文件或符号通过键入它们的名字。 Ctrl+Shift+Tab 带我们回到最后一次打开的文件集。 Ctrl+Shift+P 带我们直接进入命令编辑面板。 Ctrl+Shift+O 带我们直接导航到一个文件的符号信息。 Ctrl+G 导航到文件的指定行。 键入 ? 可得到一个可用命令的列表，可以直接在这里选中执行。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ide"],"content":"html 相关插件 Prettier 代码格式化。 CSS Peek 关联 Html 中对标签到 CSS 文件。 Html Boilerplate Html 模版。 Color Info CSS 颜色提示。 Auto Close Tag 自动闭合标签。 Html CSS Suport Html 标签引用 CSS 样式提示。 ","date":"2019-09-21","objectID":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["ide","vscode"],"title":"Visual Studio Code 学习笔记","uri":"/visual-studio-code-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"常见系统整理 搭建了一些常见系统，以便需要时能快速开箱即用。 MQ 服务：RabbitMQ WebRTC 服务：janus ELK 日志服务：elk SRS 实时流媒体服务：srs ","date":"2019-08-04","objectID":"/shortcut/:0:1","tags":null,"title":"","uri":"/shortcut/"},{"categories":null,"content":" 路的尽头是风景 ","date":"2019-08-04","objectID":"/about/:0:0","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":null,"content":"介绍  笔记主人：奉锐  坐标：成都  邮箱：qjdev@qq.com  微信：feng_rui  从事软件开发多年，前后端均有涉猎，主力语言 C#、javascript，欢迎探讨交流。 ","date":"2019-08-04","objectID":"/about/:0:1","tags":null,"title":"关于 free 笔记","uri":"/about/"},{"categories":["wpf"],"content":"常用Path路径 正三角形（左）：\u003cPath Data=“M40,0 L0,30 40,60 z” Stretch=“Uniform”/\u003e 正三角形（上）：\u003cPath Data=“M0,40 L30,0 60,40 z” Stretch=“Uniform”/\u003e 正三角形（右）：\u003cPath Data=“M0,0 L40,30 0,60 z” Stretch=“Uniform”/\u003e 正三角形（下）：\u003cPath Data=“M0,0 L30,40 60,0 z” Stretch=“Uniform”/\u003e 矩形：\u003cPath Data=“M0,0 L1,0 L1,1 L0,1 z” Stretch=“Uniform”/\u003e 圆形：\u003cPath Data=“M100,50 C100,77.614237 77.614237,100 50,100 C22.385763,100 0,77.614237 0,50 C0,22.385763 22.385763,0 50,0 C77.614237,0 100,22.385763 100,50 z” Stretch=“Uniform”/\u003e 箭头（左）：\u003cPath Data=“M40,0 L0,30 40,60” Stretch=“Uniform”/\u003e 箭头（上）：\u003cPath Data=“M0,40 L30,0 60,40” Stretch=“Uniform”/\u003e 箭头（右）：\u003cPath Data=“M0,0 L40,30 0,60” Stretch=“Uniform”/\u003e 箭头（下）：\u003cPath Data=“M0,0 L30,40 60,0” Stretch=“Uniform”/\u003e 半圆（左）：\u003cPath Data=“M34,0 L34,68 C15.222317,68 0,52.777684 0,34 0,15.222319 15.222317,3.5762787E-07 34,0 z” Stretch=“Uniform”/\u003e 半圆（上）：\u003cPath Data=“M34,0 C52.777684,7.1525574E-07 68,15.222319 68,34.000001 L0,34.000001 C3.5762787E-07,15.222319 15.222319,7.1525574E-07 34,0 z” Stretch=“Uniform”/\u003e 半圆（右）：\u003cPath Data=“M0,0 C18.777683,3.5762787E-07 34,15.222319 34,34 34,52.777684 18.777683,68 0,68 z” Stretch=“Uniform”/\u003e 半圆（下）：\u003cPath Data=“M0,0 L68,0 C68,18.777681 52.777684,34 34,34 15.222319,34 3.5762787E-07,18.777681 0,0 z” Stretch=“Uniform”/\u003e 椭圆矩形（水平）：\u003cPath Data=“M34,0 L76,0 C94.777683,9.8347664E-07 110,15.222319 110,34.000001 110,52.777684 94.777683,68.000001 76,68.000001 L34,68.000001 C15.222317,68.000001 0,52.777684 0,34.000001 0,15.222319 15.222317,9.8347664E-07 34,0 z” Stretch=“Uniform”/\u003e 椭圆矩形（垂直）：\u003cPath Data=“M34.000001,0 C52.777684,0 68.000001,15.222321 68.000001,34 L68.000001,76 C68.000001,94.777681 52.777684,110 34.000001,110 15.222319,110 8.9406967E-07,94.777681 0,76 L0,34 C8.9406967E-07,15.222321 15.222319,0 34.000001,0 z” Stretch=“Uniform”/\u003e 菱形:\u003cPath Data=“M150,0 L0,75 0,225 150,300 300,225 300,75 z” Stretch=“Uniform”/\u003e Stretch 默认使用 Uniform，在这种参数下矩形为正方形、圆形为正圆形，如果修改 Stretch 为 Fill，则根据容器高宽进行自由拉伸。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:1:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"动画 缓动函数（使用 IE 查看）：http://tinyurl.com/animationeasing WPF 动画默认为 60 帧/s，程序会在系统资源允许的情况下努力使动画达到这个帧率，也可以在代码里手动指定帧率，修该附加属性 Timeline.DesiredFrameRate 的值。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:2:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"变化 LayoutTransform：对元素使用该变换时会真正改变元素的大小和位置，从而引发布局容器的重新计算，因此，只当使用该变化一次，不要在动画中使用。 RenderTransform：显示变化，对元素运用该变化时并不会真正的改变元素的大小和位置，只是显示上面产生了变化，因此不会影响布局容器的测量和排版。 RenderTransformOrigin：使用变化时可以在具体变化中使用决对坐标，也可以直接指定元素的RenderTransformOrigin，从而使用相对坐标，比如\"0.5,0.5\"就是该元素的中心点。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:3:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"字体 WPF 有个问题是小文本显示不太清晰，原因是 WPF 没有使用 GDI 渲染文本，好的解决方法是增大文本，在通常的 96 dpi 的显示器上，文本字号最小控制在 15，如果小于这个值最好将文本的 TextOptions.TextFormattingMode 的值设置为 Display，而不是标准的 Ideal，这样做会使文本更清晰。 检查字体版权是否允许在自己的程序中嵌入，可使用工具：https://www.microsoft.com/en-us/Typography/TrueTypeProperty21.aspx，如果右键属性显示可安装就可以使用。 字体加载的两种方式，第一种字体为嵌入式资源：FontFamily=\"pack://application:,,,/WpfLabs;component/FontFamilyDemo/#Aileron\"；第二种字体为文件，可在后台代码中设置：new FontFamily（@\"D:\\FontFamilyDemo\\FontFiles\\#Aileron\"）;。 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:4:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"性能 WPF 中，很多元素继承了 Freezable，表示该元素支持冻结，冻结之后变更通知就失效了，但是内存占用会下降，很多情况下都可以将元素冻结，常见的比如 SolidColorBrush 和 Storyboard。在 Xaml 中使用时先引用命名空间 xmlns:options=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation/options\"，然后对元素使用 \u003cStoryboard options:Freeze=\"True\"\u003e。 集合虚拟化：启用 UI 虚拟化的两个附加属性 1、ScrollViewer.CanContentScroll=\"True\"；2、VirtualizingStackPanel.IsVirtualizing=\"True\"。 大集合项容器再循环，项容器再循环提高了滚动性能，降低了内存消耗量：VirtualizingStackPanel.VirtualizationMode=\"Recycling\" 当集合中使用了分组，默认不会启用虚拟化，需要手动设置 VirtualizingStackPanel.IsVirtualizingWhenGrouping 属性纠正这个问题 \u003cListBox VirtualizingStackPanel.IsVirtualizingWhenGrouping=\"True\"...\u003e ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:5:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"绑定 Xaml 中 String.Format 的使用参考：https://www.cnblogs.com/candyzkn/p/4476832.html Uri 绑定资源路径写法：pack://application:,,,/WpfLabs;component/FontFamilyDemo/#Aileron Uri 绑定本地文件路径写法：pack://siteoforigin:,,,/Aileron.jpg ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:6:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["wpf"],"content":"错误验证 显示错误提示可使用专用的错误模板，即再真正的元素之上附加一层装饰层来展示真正的错误，注意在错误模板中使用 AdornedElementPlaceholder 来标识真正的控件元素，然后使用路径属性绑定去寻找真正的错误提示，参考 19.4.5。 文章中提到的参考来源默认为 《WPF 编程宝典：使用 C# 2012 和 .NET 4.5 第 4 版》 ","date":"2019-04-28","objectID":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/:7:0","tags":["dotnet","wpf","resource"],"title":"WPF 技术点","uri":"/wpf-%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"categories":["deploy"],"content":"场景： 有些场景下会出现局域网内的某些网段可能由于安全限制，不能访问外网，此时可以通过安装一些工具来实现借助局域网内某些能够上外网的电脑来实现网络代理的功能。以下工具均是使用于Window环境。 服务端： 部署于可以上外网的电脑上，首先下载 TcpRoute2，该软件的作用是通过 Socks5 代理协议对外提供服务。下载完成后在文件夹下有个 config.toml.example 文件，删掉 .example 后缀，修改配置文件中的 addr= 字段为对应的电脑 IP，然后运行 TcpRoute2Windows.exe 程序即可开启代理服务。 客户端： 部署于局域网中需要上网的电脑上，首先下载 Proxifier，下载完毕后安装，安装完毕后首先配置代理的服务的地址，选择 Profile -\u003e Proxy Servers，添加之前服务端 addr= 填写的地址和端口，选择 Socks5 协议，认证如果服务端没有配置就可以不用修改，点击 Check，没有问题后可直接确定。然后选择 Profile-\u003eProxification Rules，可以修改现有规则或者启用一个新规则，其中 Applications、Target hosts、Target ports 都可以填 Any，最后的 Action 选择刚才建立的服务地址，然后该机器就能够全局通过代理上网了。不过要注意不能用 Ping 命令测试是否能上网，因为 Ping 命令不会走代理协议。 备注： TcpRoute 是一款开源软件，Proxifier 是一款商业软件，可以免费试用 30 天，不过网上很容易找到注册码，以下是我之前找的，用户名随意填写，注册码：5EZ8G-C3WL5-B56YG-SCXM9-6QZAP、G3ZC7-7YGPY-FZD3A-FMNF9-ENTJB、YTZGN-FYT53-J253L-ZQZS4-YLBN9 三选一。 ","date":"2019-04-01","objectID":"/windows-%E4%B8%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/:0:0","tags":["deploy"],"title":"Windows 下搭建网络代理","uri":"/windows-%E4%B8%8B%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"},{"categories":["dotnet"],"content":"安装 CentOs，可使用最小安装包镜像 http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1708.iso ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:1:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"跟随安装步骤进行，中途要选择磁盘 选择磁盘 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:2:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"设置 Root 用户密码 设置 Root 用户密码 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:3:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装完毕后重启，进入系统，CentOs 最小版缺少一些必要组件，首先要打开网卡设置，用vi编辑 vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑最后一行，将 ONBOOT=no 改为 ONBOOT=yes :wq 保存并退出 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:4:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"重启网卡 service network restart 然后Ping一下百度，应该 OK 了 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:5:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 ipconfig 等网络工具 中途需要输入 y 确认几次：sudo yum install net-tools ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:6:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"使用 ifconfig 查看本机 IP 查看本机 IP ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:7:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"下载 Putty 使用IP地址可进行远程连接： 远程连接 ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:8:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 Nginx 参考教材https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 安装 Nginx：sudo yum install epel-release; sudo yum install nginx 启动 Nginx：sudo systemctl start nginx 打开防火墙：sudo firewall-cmd --permanent --zone=public --add-service=http; sudo firewall-cmd --permanent --zone=public --add-service=https 重新加载防火墙：sudo firewall-cmd --reload ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:9:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"现在可以使用命令在Web浏览器访问Nginx了 http://server_domain_name_or_IP/ ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:10:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["dotnet"],"content":"安装 .Net Core 环境 https://www.microsoft.com/net/download/linux-package-manager/centos/sdk-current sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e \"[packages-microsoft-com-prod]\\nname=packages-microsoft-com-prod \\nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" \u003e /etc/yum.repos.d/dotnetdev.repo' sudo yum update sudo yum install libunwind libicu sudo yum install dotnet-sdk-2.1.4 至此，可输入 dotnet --version 查看 .NetCore 已安装成功。 参考： http://video.jessetalk.cn/course/4/task/6/show http://video.jessetalk.cn/course/4/task/7/show ","date":"2018-03-10","objectID":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/:11:0","tags":["dotnet"],"title":"CentOS 部署 .NetCore 服务","uri":"/centos-%E9%83%A8%E7%BD%B2-.netcore-%E6%9C%8D%E5%8A%A1/"},{"categories":["wpf"],"content":"在 WPF 中使用动画的情况非常多，而要让动画变得生动往往要使用一些变速动画，WPF 也内置了很方便的缓动函数来实现这一功能。 除此之外，WPF 还有关键帧动画，利用关键帧动画能够很好的控制动画的细节，与美工的很多设计保持完美一致。关键帧动画中还有一套叫做样条关键帧动画（SplineKeyFrame），这个动画利用一个三次贝塞尔曲线能够更准确的控制动画的速率。 不同的缓动函数光看名字很难知道实际效果，样条关键帧动画的贝塞尔曲线控制也很难直观的看到效果，于是写了个小工具来展现不同的动画速率的效果以及修改配置对速率的影响，下面是工具的运行效果。 动画速率效果 工具代码下载地址：https://github.com/fengrui358/WPFLabs/tree/master/EasingFunctionDemo 三次贝塞尔曲线控制参考：https://www.cnblogs.com/hnfxs/p/3148483.html ","date":"2017-12-04","objectID":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/:0:0","tags":["dotnet","wpf"],"title":"WPF 动画速率效果","uri":"/wpf-%E5%8A%A8%E7%94%BB%E9%80%9F%E7%8E%87%E6%95%88%E6%9E%9C/"},{"categories":["ui"],"content":" 正三角形(左)：\u003cPath Data=“M40,0 L0,30 40,60 z” Stretch=“Uniform”/\u003e 正三角形(上)：\u003cPath Data=“M0,40 L30,0 60,40 z” Stretch=“Uniform”/\u003e 正三角形(右)：\u003cPath Data=“M0,0 L40,30 0,60 z” Stretch=“Uniform”/\u003e 正三角形(下)：\u003cPath Data=“M0,0 L30,40 60,0 z” Stretch=“Uniform”/\u003e 矩形：\u003cPath Data=“M0,0 L1,0 L1,1 L0,1 z” Stretch=“Uniform”/\u003e 圆形：\u003cPath Data=“M100,50 C100,77.614237 77.614237,100 50,100 C22.385763,100 0,77.614237 0,50 C0,22.385763 22.385763,0 50,0 C77.614237,0 100,22.385763 100,50 z” Stretch=“Uniform”/\u003e 箭头(左)：\u003cPath Data=“M40,0 L0,30 40,60” Stretch=“Uniform”/\u003e 箭头(上)：\u003cPath Data=“M0,40 L30,0 60,40” Stretch=“Uniform”/\u003e 箭头(右)：\u003cPath Data=“M0,0 L40,30 0,60” Stretch=“Uniform”/\u003e 箭头(下)：\u003cPath Data=“M0,0 L30,40 60,0” Stretch=“Uniform”/\u003e Stretch 默认使用 Uniform，在这种参数下矩形为正方形、圆形为正圆形，如果修改 Stretch 为 Fill，则根据容器高宽进行自由拉伸。 ","date":"2017-07-22","objectID":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/:0:0","tags":["ui","wpf"],"title":"常用 Path 路径","uri":"/%E5%B8%B8%E7%94%A8-path-%E8%B7%AF%E5%BE%84/"},{"categories":["dotnet"],"content":" 警告 如果在一个类中定义了虚属性或者虚方法，又在构造函数中访问了这个虚属性或方法，此时 VisualStudio 是不会给出警告，并且编译也没有问题，但是如果安装了 Resharper 插件则会给出警告提示：“在构造函数中访问了虚成员”，那么，这为何是一个安全隐患，下面给出一个例子说明： using System; namespace VirtualDemo { class Program { static void Main(string[] args) { var test = new SubClass(); Console.ReadKey(); } } class BaseClass { protected virtual string VirtualProperty { get; set; } public BaseClass() { var p = VirtualProperty; VirtualMethod(); } protected virtual void VirtualMethod() { } } class SubClass : BaseClass { private MockClass _mockClass; public SubClass() { _mockClass = new MockClass(); } protected override string VirtualProperty { get { return _mockClass.MockProperty; } set { _mockClass.MockProperty = value; } } protected override void VirtualMethod() { var p = _mockClass.MockProperty; } } class MockClass { public string MockProperty { get; set; } } } 该示例很简单，在构造 SubClass 时出现了空引用报错，因为基类构造函数先于子类构造函数运行，而子类构造函数中初始化了一个成员类，但是基类构造函数访问虚成员时子类还没构造，所以出现了空引用报错。有多种方式可以避免这一情况，可以通过子类字段初始化的方式来构造成员类，这个语法糖可避免构造函数的时序问题，第二个是可定义一个虚的 Initialize 方法在子类构造函数第一步调用，子类在继承这个方法时初始化需要的依赖。 ","date":"2017-06-03","objectID":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/:0:0","tags":["dotnet"],"title":"C# 为何不推荐在构造函数中访问虚成员","uri":"/csharp%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%99%9A%E6%88%90%E5%91%98/"},{"categories":["dotnet"],"content":"纵览 NLog 在启动时会自动的去加载配置，总的说来 NLog 的配置会来源于两个地方： 配置嵌入在标准的 *.exe.config 或者 web.config 文件。 存储在一个单独的配置文件中。 对于 Xamarin Android，支持将配置文件放在 assets 文件夹下。不过它不能自动加载，需要手动配置，如下： LogManager.Configuration = new XmlLoggingConfiguration(\"assets/nlog.config\"); 第一种使用标准配置的情况代码如下： \u003cconfiguration\u003e \u003cconfigSections\u003e \u003csection name=\"nlog\" type=\"NLog.Config.ConfigSectionHandler, NLog\"/\u003e \u003c/configSections\u003e \u003cnlog\u003e \u003c/nlog\u003e \u003c/configuration\u003e 第二种使用纯粹的 XML 格式再\u003cnlog /\u003e根节点下添加配置，并且当加入命名空间时还能够获得 Visual Studio 的智能提示。 \u003cnlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\u003e \u003c/nlog\u003e 注意当不添加命名空间时 NLog 配置文件是大小写不敏感的，而使用命名空间则配置文件就变得大小写敏感。智能提示只工作在大小写敏感的配置中。\u003cnlog /\u003e 根节点中可以添加如下的孩子元素，其中头两个为必须添加的元素，其他三个用于一些高级功能。 \u003ctargets /\u003e - 定义日志目标和输出 \u003crules /\u003e - 定义日志的路由规则 \u003cextensions /\u003e - 从*.dll 文件中加载的 NLog 扩展 \u003cinclude /\u003e - 定义包括的额外配置文件 \u003cvariable /\u003e - 设置配置文件的变量值 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:1:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Targets 每一个 \u003ctargets /\u003e 节点定义来一个日志输出目标，每个目标有两个属性是必须的: name - 目标的名称 type - 枚举值，如:“File”，“Database”，“Mail”。当引用来命名空间时需要使用xsi:type 然后除了必要的两个属性以外根据不同的 type 还会有一些不同的参数属性，这个后面讲 targets 时会详细讲到。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:2:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Rules 日志路由规则定义在 \u003crules /\u003e 节点下，这个路由表定义了一系列的规则来约束日志对象的名称、日志等级和它们的输出目标的关系。运算时从 rules 的第一条规则开始计算，如果匹配就立即输出到指定到目标，然后计算下一条规则，如果匹配到一条被标记为 final 的规则，则不再往下计算。 路由表中的每一条规则都是一个 \u003clogger /\u003e 元素，包括以下属性： name - 日志的名称（包括通配符 *） minlevel - 该规则能匹配的最低日志等级 maxlevel - 该规则能匹配的最高日志等级 level - 只匹配某一个单独的日志等级 levels - 该规则可匹配多个日志等级，用 , 分隔符分开 writeTo - 指定输出到到目标，可以是多个，用 , 分隔符分开 final - 标记该条规则为最后一条，在该条规则匹配到情况下不再继续往后匹配 enabled - 设置为 false 则禁用该规则 假如在同一条规则中包含来多个日志等级到关键字（level，levels，minlevel，maxlevel），则按照日志等级关键字的优先顺序来设置优先级，只取优先级最高的那个关键字，其他的忽略。 日志等级关键字的优先顺序如下： level levels minlevel 和 maxlevel（最低和最高等级的优先级相同） 没有关键字（默认为全部等级） ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:3:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Layouts and layout renderers Nlog 其中最强大的一个组件就是 layouts。layouts 的主要作用是使用嵌入标记 ${ 和 } 来嵌入一些上下文信息。 layouts 可以用于很多地方，例如它们可以控制输出到屏幕或文件内到文本信息到格式，也可以控制输出到文件时的要用的文件名。 下面是一个示例，我们将以下信息写入到控制台中： 当前日期和时间 输出该段日志段类和方法名称 日志等级 日志信息 以上基本上是日常使用最长用的信息，要输出以上信息也非常简单： \u003ctarget name=\"c\" xsi:type=\"Console\" layout=\"${longdate} ${callsite} ${level} ${message}\" /\u003e 我们也可以指定不同的日志对象将它们对应的日志信息分别输出到对应到日志文件中，如下： \u003ctarget name=\"f\" xsi:type=\"File\" fileName=\"${logger}.txt\" /\u003e 使用 ${logger} 就可以创建如下到日志文件列表： Name.Space.Class1.txt Name.Space.Class2.txt Name.Space.Class3.txt Other.Name.Space.Class1.txt Other.Name.Space.Class2.txt Other.Name.Space.Class3.txt ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:4:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"分隔配置文件（Include files） 有时我们会希望将一个大的配置文件分隔成多个小的，Nlog 也提供来一个机制在主配置文件中包括额外的配置文件，使用 \u003cinclude file=\"……\"/\u003e 元素。而其中额外的配置文件的名称也可以使用 ${} 语法嵌入动态的文件名，跟在 layout 中使用它没什么区别，所以我们也可以根据不同的环境指定不同的配置文件，例子如下，我们根据运行环境所在的不同机器使用不同的配置文件： \u003cnlog\u003e ... \u003cinclude file=\"${basedir}/${machinename}.config\"/\u003e ... \u003c/nlog\u003e 其中有一个可选属性，ignoreError=\"true\"，该属性的默认值为 false。添加这个属性的作用是当额外配置文件没有找到或是格式不正确时可以阻止 Nlog 抛出异常，当设置 ignoreError=\"true\"，配置的异常信息只会记录在 Nlog 的内部调试日志当中，此时可以通过 Troubleshooting logging 来记录内部错误。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:5:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Variables 变量为编写复杂和重复的内容提供了一种简明的表达形式。可以使用如下的语法定义一个变量： \u003cvariable name=\"var\" value=\"xxx\" /\u003e 一旦变量定义好之后，就可以使用类似 ${var} 这样的语法使用它了，例子如下： \u003cnlog\u003e \u003cvariable name=\"logDirectory\" value=\"${basedir}/logs/${shortdate}\"/\u003e \u003ctargets\u003e \u003ctarget name=\"file1\" xsi:type=\"File\" fileName=\"${logDirectory}/file1.txt\"/\u003e \u003ctarget name=\"file2\" xsi:type=\"File\" fileName=\"${logDirectory}/file2.txt\"/\u003e \u003c/targets\u003e \u003c/nlog\u003e 需要注意变量的声明必须在使用之前，否则配置初始化会失败。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:6:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"Vars since NLog 4.1 在 NLog 4.1 版本中有一个新方法来使用变量，用 ${var:var1} 来代替 ${var1}。 在 layout renderer 中使用这种写法的好处是： 可以通过 API 来改变，删除和新建变量。 可以为变量配置一个默认值，如：${var:password:default=unknown}。 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:6:1","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["dotnet"],"content":"自动重载配置 配置文件在程序启动时会自动加载 NLog 配置大全 ","date":"2017-04-26","objectID":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/:7:0","tags":["dotnet","log"],"title":"NLog 配置详解","uri":"/nlog-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["wpf"],"content":"在 WPF 的集合控件中常常需要在每一个集合项之间插入一个分隔符样式，但是 WPF 的 ItemsControl 没有相关功能的直接实现，所以只能考虑曲线救国，经过研究，大概想到了以下两种实现方式。 先写出 ItemsControl 的数据模板，如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\"\u003e \u003cItemsControl.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\" /\u003e \u003cTextBlock Grid.Row=\"1\" Text=\"{Binding}\" /\u003e \u003c/Grid\u003e \u003c/DataTemplate\u003e \u003c/ItemsControl.ItemTemplate\u003e \u003c/ItemsControl\u003e 其中名为 Bd 的 Border 就是分隔符，此时每一项的头部都可以看见分隔符，现在我们的目标是要隐藏掉第一项的分隔符，这就达到了项与项之间才有分隔符的目的。 第一种实现方式最简单，使用集合项前向绑定 PreviousData，这是四种绑定方式中的一种，估计也是平时用得最少的一种，不过此时就派上用场了，代码如下： \u003cDataTemplate.Triggers\u003e \u003cDataTrigger Binding=\"{Binding RelativeSource={RelativeSource PreviousData}}\" Value=\"{x:Null}\"\u003e \u003cSetter TargetName=\"Bd\" Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/DataTemplate.Triggers\u003e 当某一项的前项为空时就隐藏分隔符，简单的一行代码搞定。不过这种实现方式有个缺点就是如果使用的是 Insert 方式向绑定的数据源的最前面添加数据则就会出现不止一个没有分隔符的项，如果是往队尾或者队中添加则不会出现这个问题。 第二种实现方式是借助 ItemsControl 的 AlternationCount 和 AlternationIndex 属性来为集合项标记索引号，再隐藏索引号为 0 的项的分隔符，代码如下： \u003cItemsControl ItemsSource=\"{Binding Source}\" BorderThickness=\"1\" BorderBrush=\"Blue\" VerticalAlignment=\"Stretch\" AlternationCount=\"{Binding Source.Count}\"\u003e 首先在 ItemsControl 上绑定 AlternationCount 到数据源的 Count 属性上，然后此时 ItemsControl 的 AlternationIndex 属性就变成的该集合数据源的索引号了，在触发器中写上逻辑即可： \u003cBorder Name=\"Bd\" Grid.Row=\"0\" Height=\"1\" Background=\"Red\"\u003e \u003cBorder.Style\u003e \u003cStyle TargetType=\"{x:Type Border}\"\u003e \u003cStyle.Triggers\u003e \u003cDataTrigger Binding=\"{Binding Path=(ItemsControl.AlternationIndex), RelativeSource={RelativeSource AncestorType={x:Type ContentPresenter}}}\" Value=\"0\"\u003e \u003cSetter Property=\"Visibility\" Value=\"Collapsed\" /\u003e \u003c/DataTrigger\u003e \u003c/Style.Triggers\u003e \u003c/Style\u003e \u003c/Border.Style\u003e \u003c/Border\u003e 触发器判定当索引号为0时就隐藏 Border，这种方式代码量也不大，优点是能绝对实现这个功能，无论向队首插入还是队尾插入，但是 AlternationCount 和 AlternationIndex 属性本来的含义是用来实现比如隔行变色等功能，此时这种功能被占用，所以如果你的集合要同时实现分隔符和隔行样式的功能可能需要额外加转换器，不过转换器内容也很简单，求个余数就能还原之前的功能了。 （2017 年 4 月 15 日补充） 经过网友 vbfool 提示，补充第三种方式，按照第二种思路自定义附加属性，这样就不用占用原生 ItemsControl 的属性了。并且可以用附加属性标记出所有的索引号，供其他场景使用。 先自定义一个 MarkIndex 属性用于标记 ItemsControl，如果这个属性被设为 True 再在代码逻辑中去订阅数据项的变更，然后向 ItemContainer 中设置一个 ItemIndex 附加属性，标记出索引号。 定义的依赖属性如下： #region MarkIndex public static readonly DependencyProperty MarkIndexProperty = DependencyProperty.RegisterAttached( \"MarkIndex\", typeof(bool), typeof(ItemsControlHelper), new PropertyMetadata(default(bool), OnMarkIndexPropertyChanged)); public static bool GetMarkIndex(DependencyObject obj) { return (bool)obj.GetValue(MarkIndexProperty); } public static void SetMarkIndex(DependencyObject obj, bool value) { obj.SetValue(MarkIndexProperty, value); } private static void OnMarkIndexPropertyChanged(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs args) { if ((bool)args.NewValue) { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; itemsControl.ItemContainerGenerator.StatusChanged += ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged += ItemContainerGeneratorOnItemsChanged; } } else { var itemsControl = dependencyObject as ItemsControl; if (itemsControl != null) { itemsControl.ItemContainerGenerator.StatusChanged -= ItemContainerGeneratorOnStatusChanged; itemsControl.ItemContainerGenerator.ItemsChanged -= ItemContainerGeneratorOnItemsChanged; } } } private static void ItemContainerGeneratorOnItemsChanged(object sender, ItemsChangedEventArgs itemsChangedEventArgs) { var itemContainerGenerator = (ItemContainerGenerator)sender; if (itemContainerGenerator.Status == GeneratorStatus.ContainersGenerated) { for (int i = 0; i \u003c itemContainerGenerator.Items.Count; i++) { var dp = itemContainerGenerator.ContainerFromIndex(i); if (dp != null) {","date":"2017-04-10","objectID":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/:0:0","tags":["dotnet","wpf"],"title":"WPF 集合控件实现分隔符（ItemsControl Separator）","uri":"/wpf-%E9%9B%86%E5%90%88%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6itemscontrol-separator/"},{"categories":["dotnet"],"content":"安装 Nlog 通过 NuGet 安装，可以看到排名靠前的有两个，一个是 NLog，还有一个是 NLog.Config，推荐安装第二个，除了安装 NLog 程序集以外还会安装它的配置文件和一个配置文件 XML 结构的描述文件（让 Visual Studio 支持配置文件的智能提示）。 也可以通过 NuGet Console 用命令行安装：Install-Package NLog.Config。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:1:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"日志等级 跟大多数日志框架一样，NLog 也有很多内置的日志等级，使用时可以根据日志名称和等级通过配置筛选想看到的日志。 NLog 支持的日志等级如下： Trace - 最细的调试等级，比如要调试很细微的通讯协议可以用该等级。该等级一般只用于开发阶段。 Debug - 调试等级，没有 Trace 等级细，用于调试系统的运行流程。该等级一般不用于生产环境。 Info - 一般信息。该等级一般用于生产环境。 Warn - 警告等级，一般是一些不会引起严重问题的警告，可以恢复或只是一些临时性的故障。 Error - 错误，大多数时候用于显示程序捕获到的 Excetion。 Fatal - 崩溃，非常严重的错误。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:2:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"创建日志记录对象 NLog 有两个最常用的类，一个是：Logger，另一个是：LogManager。Logger 提供一系列记录日志的 API，而 LogManager 负责创建 Logger 对象。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:3:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"记录日志信息 通过 Logger 对象调用不同的日志等级名称命名的 API 来记录日志，也可以使用 Log() 方法传入日志等级的枚举作为参数来记录日志。 using NLog; public class MyClass { private static Logger logger = LogManager.GetCurrentClassLogger(); public void MyMethod1() { logger.Trace(\"Sample trace message\"); logger.Debug(\"Sample debug message\"); logger.Info(\"Sample informational message\"); logger.Warn(\"Sample warning message\"); logger.Error(\"Sample error message\"); logger.Fatal(\"Sample fatal error message\"); // alternatively you can call the Log() method // and pass log level as the parameter. logger.Log(LogLevel.Info, \"Sample informational message\"); } } 你可以直接使用这些日志 API 来格式化字符串，就跟使用 Console.WriteLine() 和 String.Format() 一样。 using NLog; public class MyClass { private static Logger logger = LogManager.GetCurrentClassLogger(); public void MyMethod1() { int k = 42; int l = 100; logger.Trace(\"Sample trace message, k={0}, l={1}\", k, l); logger.Debug(\"Sample debug message, k={0}, l={1}\", k, l); logger.Info(\"Sample informational message, k={0}, l={1}\", k, l); logger.Warn(\"Sample warning message, k={0}, l={1}\", k, l); logger.Error(\"Sample error message, k={0}, l={1}\", k, l); logger.Fatal(\"Sample fatal error message, k={0}, l={1}\", k, l); logger.Log(LogLevel.Info, \"Sample informational message, k={0}, l={1}\", k, l); } } 提示： 但是要避免使用 String.Format() 来直接格式化日志内容，而要使用 NLog 自己的 API 来格式化，主要原因是出于性能考虑。 如果使用 NLog 的 API 来格式化，那么 NLog 只会在在这段日志确定会被输出到某个目标时才执行格式化操作，而如果使用 String.Format()，那么每当代码运行到这里都会执行字符串格式化。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:4:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"配置 NLog 的配置比起 log4net 就要简单清晰得多来，而且在 Visual Studio 里加载配置的 XML 架构描述文件后还有智能提示，对于入门选手来说可谓是相当的简单。 NLog 的配置主要有两个方面，第一个是要配置输出日志的目标，就是定义一个存储日志的地方；第二个就是定义一个日志对象，日志对象需要定义要输出的日志的级别，再关联一个输出目标就可以来。如下是一个最简单的输出到文本文件的配置： \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cnlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\u003e \u003ctargets\u003e \u003ctarget name=\"logfile\" xsi:type=\"File\" fileName=\"file.txt\" /\u003e \u003c/targets\u003e \u003crules\u003e \u003clogger name=\"SomeNamespace.Component.*\" minlevel=\"Trace\" writeTo=\"logfile\" final=\"true\" /\u003e \u003clogger name=\"*\" minlevel=\"Info\" writeTo=\"logfile\" /\u003e \u003c/rules\u003e \u003c/nlog\u003e ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:5:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"其他知识点 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:0","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"内部诊断日志 内部诊断日志是 NLog 自身的调试日志，一般情况下不必打开，主要用来调试 NLog 不正常工作的情况，比如日志没有按照配置输出到指定地方，或者 NLog 扩展没有正常工作等情况。打开内部诊断日志很简单，需要在配置的根节点 \u003cnlog\u003e 下面配置以下几个特性： internalLogFile=\"file.txt\" - 指定内部诊断日志的输出路径。 internalLogLevel=\"Trace|Debug|Info|Warn|Error|Fatal|Off\" – 决定内部诊断日志输出的最小等级，跟我们外部调用者一样，内部诊断日志对象也是分等级的。 internalLogToConsole=\"false|true\" – 是否输出内部诊断日志到控制台。 internalLogToConsoleError=\"false|true\" – 是否输出内部诊断日志到控制台的错误输出。（stderr，不太明白跟上一个的区别） 下面是一个比较完整的配置： \u003cnlog internalLogFile=\"c:\\log.txt\" internalLogLevel=\"Trace\"\u003e \u003ctargets\u003e \u003c!-- target configuration here --\u003e \u003c/targets\u003e \u003crules\u003e \u003c!-- log routing rules --\u003e \u003c/rules\u003e \u003c/nlog\u003e 当然，使用程序代码也能配置内部日志参数： using NLog; using NLog.Common; class Program { static void Main() { // enable internal logging to the console InternalLogger.LogToConsole = true; // enable internal logging to a file InternalLogger.LogFile = \"c:\\\\log.txt\"; // set internal log level InternalLogger.LogLevel = LogLevel.Trace; } } ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:1","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["dotnet"],"content":"性能优化 之前比较过 NLog 和 Log4Net 的性能，NLog 略胜一筹，但是在使用的过程当中还是有几点需要注意。 不要使用 string.format 来格式化字符串参数，而是将字符串参数直接传给 NLog 的方法。 不要使用多线程去写多个文件。 可以使用条件日志 “Conditional logging”，用法如下： Conditional logging 当存在使用大量诊断日志的情况下，从 NLog4.0 开始可以使用这种方法来优化： Logger.Trace(\"entering method {0}\", methodname); 替换为 Logger.ConditionalTrace(\"entering method {0}\", methodname); 这段日志的调用只会在 .Net 编译器添加 DEBUG 条件的时候才会包含进去。 ","date":"2017-03-16","objectID":"/nlog-%E7%AE%80%E4%BB%8B/:6:2","tags":["dotnet","log"],"title":"NLog 简介","uri":"/nlog-%E7%AE%80%E4%BB%8B/"},{"categories":["deploy"],"content":"步骤如下 创建AWS账号，可获得一年期限的限制条件免费试用，主要流程跟着网上的教程走，具体优惠的限制在其他教程中已说得比较清楚了，不再赘述。**重点：**需要一张信用卡，然后注册验证的时候会从信用卡扣1美元，然后需要一个电话，亚马逊机器人会打这个电话，按提示在电话中输入网页上的验证码。 创建 Windows Server 2008 R2 镜像（由于本人没玩过 Linux、Windows Server 2012 也没尝试成功，所以最后使用的是 2008）。**重点：**在安全组策略中，AWS 已为我们的实例开启了 RDP 3389 端口以供远程桌面访问，修改为允许所有流量从任何 IP 进入（之前尝试了开放部分端口，比如 1723、1701，但是客户端连接不成功）。 img 创建实例，具体选择在哪个地区创建实例可通过这个网址进行测试http://www.cloudping.info，我自己选的韩国首尔，然后通过秘钥获得 VPS 实例的初始密码。 img 在控制面板左侧申请一个弹性IP绑定在刚才创建的实例上。 img 远程访问实例，降低本地安全策略的密码强度（可选），然后设置自己的管理员密码。 img 功能安装，安装远程访问与远程路由（Routing and Remote Access Services）的功能。 img img 安装完毕后开启 VPN 服务，自定义选择 VPN 和 NAT。 img 对 VPN 进行配置，主要是分配静态 IP，根据服务器所在的内网 IP 决定，从服务器本机 IP 开始，可往后连续分配一定数量。 img 启动 NAT。 img img 新建 VPN 用户，并设置允许访问网络然后分配之前划定的静态 IP，至此，服务端的配置就算结束了。 img img 现在开始配置客户端，客户端比较简单，先建立一个 VPN，然后输入服务器的外网 IP，然后是用户名和密码，修改本地 VPN 连接的 DNS，可用 google 的 DNS：8.8.8.8 和 8.8.4.4，一切修改完毕后就可以开始连接，如果还是不行可能还要修改本地网卡的 DNS。注意：Mac 下要选择协议 PPTP，然后高级设置里要勾选通过 VPN 连接发送所有流量。 img 总体上感觉速度还不错，虽然服务器和带宽不咋地，不过一般上上 google、查查资料还是没问题。然后测试了不同用户在不同地点登录，貌似有点问题，具体的网络原理也不太清楚。 参考：http://www.advertcn.com/thread-7568-1-1.html ","date":"2016-09-08","objectID":"/aws-vps-%E5%88%9B%E5%BB%BA-windows-server-vpn/:1:0","tags":["deploy"],"title":"AWS VPS 创建 Windows Server VPN","uri":"/aws-vps-%E5%88%9B%E5%BB%BA-windows-server-vpn/"},{"categories":["resource"],"content":"微软相关平台资源 国内的微软相关资源：http://www.itellyou.cn/ Dotnet 相关资源：https://www.microsoft.com/net/download/visual-studio-sdks Windows 操作系统官方下载工具：https://www.microsoft.com/zh-cn/software-download/windows10 C# 注释规范：https://msdn.microsoft.com/zh-cn/library/5ast78ax.aspx Dotnet 全栈之路：https://www.microsoft.com/net/architecture .Net 产品控件库：https://www.syncfusion.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:1:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"WPF 官方 MSDN（英文）：https://msdn.microsoft.com/en-us/library/ms754130.aspx 官方 MSDN（中文）：https://msdn.microsoft.com/zh-cn/library/ms754130(v=vs.110).aspx ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"Visual Studio 模板扩展下载：https://visualstudiogallery.msdn.microsoft.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:1","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"Xamarin 版本信息：https://developer.xamarin.com/releases/current/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:2:2","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"内网穿透 https://natapp.cn/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:3:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"有趣 GitHub 上的技术栈：https://octoverse.github.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:4:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"设计 ICON 资源软件 Metro Studio：https://www.syncfusion.com/downloads/metrostudio/iconpackage/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:5:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["resource"],"content":"DotNetLib 对比 https://dotnet.libhunt.com/ ","date":"2016-08-31","objectID":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/:6:0","tags":["dotnet","resource"],"title":"常用 Dotnet 资源整合","uri":"/%E5%B8%B8%E7%94%A8-dotnet-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/"},{"categories":["deploy"],"content":"Web Deploy 支持直接从本地 Visual Studio 的工程文件部署网站到远程服务器，部署的过程中可以对比哪些文件变化了需要拷贝，而不是一股脑的全部拷贝，效率和准确性会更好。 部署的过程主要要注意以下几点： ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:0:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"远程服务器的 IIS 安装管理服务 安装管理服务 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:1:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"IIS 控制面板中启动管理服务，使用 Windows 凭据还是 IIS 凭据视需要而定 IIS 凭据 完毕之后可以看到服务列表中的 WMSVC 启动 WMSVC 启动 ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:2:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"安装Web Deploy，地址 http://www.iis.net/downloads/microsoft/web-deploy ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:3:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["deploy"],"content":"本地 Visual Studio 链接测试 链接测试 注意站点名称必须和 IIS 中的站点名称匹配才能验证连接成功，还有注意你的服务器 IP 地址必须能够 Ping 通，防火墙端口 8172 必须开放。整个过程我只遇到一个问题，与这篇文章类似：http://www.benday.com/2013/07/12/fix-error_could_not_connect_to_remotesvc-error-using-visual-studio-2012-web-deploy/ ","date":"2016-06-22","objectID":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/:4:0","tags":["dotnet","deploy"],"title":"使用 Web Deploy 进行远程部署","uri":"/%E4%BD%BF%E7%94%A8-web-deploy-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/"},{"categories":["dotnet"],"content":"假如有这样一个场景，1 个 100 万用户同时在线的系统，假设有一个 Session 管理器来管理它们的存亡，每个用户的 Session 有效时间假设 5 分钟，通常一个最简单的做法是在一个 Session 管理器中启动一个 Thread 去定时校验每个 Session 是否到达有效期截止时间，将到期的 Session 清理掉，而这个需求就导致存放 Session 的字典必须支持并发。而另一种做法就是在每个 Session 对象的内部去启动一个 Timer 让 Timer 在指定时间后去校验自身是否到期，若到期则发出事件通知让管理器去做清理工作。 测试结果，使用 Thread 的方式 CPU 一直保持在 4% 左右，而使用 Timer 的方式 CPU 保持在 0，内存比 Thread 方式多用 100 多 mb。按照存储比 CPU 便宜的标准，即使是内存消耗感觉也是第二种方式会更好一些。 2017 年 3 月 9 日补充：这篇文章过时了，今天读到篇文章，原来可以用一种叫环形队列的数据结构来处理这种大量的超时任务。参见：http://mp.weixin.qq.com/s/mvFwjgxliwx808Hn_9ruEA。 ","date":"2016-06-22","objectID":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/:0:0","tags":["dotnet","async"],"title":"Timer 的性能优势","uri":"/timer-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF/"},{"categories":["xamarin"],"content":"Xamarin Android 项目在编译时会从 google 的服务器下载缺失的 m2repository 相关文件，虽然不明白这是干什么的，但是情况就是 Andorid SDK Manager 不会去下载这个东西，然后在 VS 里编译某些项目时会去下载某些版本的 m2repository 文件。 由于墙的关系这个肯定是下载不下来的，所以只能通过迅雷穿墙下载，然后拷贝到指定的目录，这个目录就是它报错的提示里的一个文件夹，路径类似于：C:\\Users\\Administrator\\AppData\\Local\\Xamarin\\zips，下载的路径可以从国内的镜像网站找，也可以根据报错提示从 google 的网站下，官方的下载路径类似于：https://dl-ssl.google.com/android/repository/android_m2repository_r10.zip 下载完毕后需要放入上面的指定文件夹，还要修改文件的名字，对应关系如下（截止至 23.3.0 版）： Android： 23.3.0 —— android_m2repository_r29.zip —————– 2A3A8A6D6826EF6CC653030E7D695C41.zip 23.2.1 —— android_m2repository_r28.zip —————– 17BE247580748F1EDB72E9F374AA0223.zip 23.1.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.1.1 —— android_m2repository_r25.zip —————– 0B3F1796C97C707339FB13AE8507AF50.zip 23.0.1.3 —— android_m2repository_r22.zip —————– 96659D653BDE0FAEDB818170891F2BB0.zip 23.0.1.1 —— android_m2repository_r20.zip —————– 650E58DF02DB1A832386FA4A2DE46B1A.zip 22.2.1 —— android_m2repository_r16.zip —————– 0595E577D19D31708195A83087881EE6.zip 22.2.0 —— android_m2repository_r15.zip —————– F9D66CC0ADC0C3787F4DAE6D494E6BC7.zip 22.1.1.1 —— android_m2repository_r14.zip —————– AB24E1C26FC70B44683752D37075AC06.zip 22.0.0 —— android_m2repository_r12.zip —————– 806FD8EEF161DCEA979C128F27BE5867.zip 21.0.3 —— android_m2repository_r10.zip —————– 1FD832DCC1792D8ACA07FAC3259FC5A9.zip 19.0.1 —— support_r19.0.1.zip —————– CED55A39D1283BB9DC217CAE987067E0.zip Google： 8.4 —— google_m2repository_r24.zip —————– CAA441D76F04E0D57C4110F8A00CDA7A.zip 以上有缺失和错误的欢迎补充，给出一个完整包的下载地址： http://pan.baidu.com/s/1boOwuZ1 ","date":"2016-05-16","objectID":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["xamarin","dotnet"],"title":"解决 Xamarin Android 墙的问题","uri":"/%E8%A7%A3%E5%86%B3-xamarin-android-%E5%A2%99%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["xamarin"],"content":"在 Xamarin 中有一些 Forms 原生不太好实现的内容可以考虑使用 HTML、Javascript、CSS 那一套前端技术来实现，使用 WebView 来承载显示本地或网络上的 HTML 文件。不像 OpenUri 方法，不是将用户带到设备中的本地浏览器里去，而是用 WebView 直接在 App 内部显示 HTML 内容。 该文档由下面几节内容组成： 内容（Content）——WebView 支持各种内容元素，包括嵌入式 HTML 文件，Web 页面和 HTML 字符串。 导航（Navigation）——WebView 支持导航到特定的页面并返回。 事件（Events）——监听并相应响应用户在 WebView 中触发的动作。 性能（Performance）——了解各平台上 WebView 的性能特点。 权限（Permissions）——了解在 App 中使用 WebView 的相应权限设置。 布局（Layout）——WebView 对布局有一些特别要求，了解如何恰当的显示 WebView。 img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Content WebView 支持下列几种内容： HTML 和 CSS 网站——WebView 全方位支持 HTML 和 CSS 布局的网站，也包括对 JavaScript 的支持。 文档（Documents）——因为 WebView 使用的是平台本地组件，所以 WebView 可以显示平台所支持的那些文档类型。这意味着，PDF 文件可以直接在 iOS 和 Android 平台上显示，但是 Windows Phone 平台不能。 HTML 字符串——WebView 可以显示内存中的 HTML 字符串。 本地文件——WebView 可以显示嵌入在 App 中的任何内容。 注意： Windows 和 Windows Phone 平台上的 WebView 并不支持 Silverlight，Flash和任何的 ActiveX 控件，即使该平台上的 Internet Explorer 浏览器都支持。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"网站（Websites） 要显示因特网上的一个网站，可以给 WebView 的 Source 属性设置一个 URL 字符串： var browser = new WebView { Source = \"http://xamarin.com\" }; 注意： URLs 地址必须是指定协议的完整格式（如：前面必须有\"http://“或”http://\"） iOS 和 ATS 自 iOS 9 以后，默认情况下仅允许应用程序和实现了最佳安全实践的服务通信，如果想和不安全的服务进行通信必须要修改 Info.plist 的设置。 注意： 如果你的应用程序需要链接一个不安全的服务，你应该使用 NSExceptionDomains 设置一些域名做为例外，而不是使用 NSAllowsArbitraryLoads 完全关闭 ATS。 NSAllowsArbitraryLoads 只应该用在某些极端紧急情况下。 下面这个例子展示了如何设置一些特殊域名（此处用 xamarim.com 举例）绕开 ATS 的检验： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSExceptionDomains\u003c/key\u003e \u003cdict\u003e \u003ckey\u003examarin.com\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSIncludesSubdomains\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionAllowsInsecureHTTPLoads\u003c/key\u003e \u003ctrue/\u003e \u003ckey\u003eNSTemporaryExceptionMinimumTLSVersion\u003c/key\u003e \u003cstring\u003eTLSv1.1\u003c/string\u003e \u003c/dict\u003e \u003c/dict\u003e \u003c/dict\u003e 良好的实践是只让一部分域名绕开 ATS 的检验，允许你访问受信任的网站同时也能更安全的访问不受信任的域名。下面的例子展示了 App 当中最不安全的一种做法，完全禁用 ATS： \u003ckey\u003eNSAppTransportSecurity\u003c/key\u003e \u003cdict\u003e \u003ckey\u003eNSAllowsArbitraryLoads \u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e 查看 App Transport Security 获取关于 iOS 9 这个新功能的更多信息。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"HTML 字符串 如果你想展示一串被代码动态定义的 HTML 字符串，你需要创建一个 HtmlWebViewSource 的实例： var browser = new WebView(); var htmlSource = new HtmlWebViewSource(); htmlSource.Html = @\"\u003chtml\u003e\u003cbody\u003e \u003ch1\u003eXamarin.Forms\u003c/h1\u003e \u003cp\u003eWelcome to WebView.\u003c/p\u003e \u003c/body\u003e\u003c/html\u003e\"; browser.Source = htmlSource; img 上面的代码中，@ 符号用于标记 HTML 作为一串字面量的字符串，所有通用转义符都会被忽略。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"本地 HTML 文件 WebView 可以直接展示嵌入在 App 中的 HTML，CSS 和 Javascript，例如： \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eXamarin Forms\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eXamrin.Forms\u003c/h1\u003e \u003cp\u003eThis is an iOS web page.\u003c/p\u003e \u003cimg src=\"XamarinLogo.png\" /\u003e \u003c/body\u003e \u003c/html\u003e CSS： html,body { margin:0; padding:10; } body,p,h1 { font-family: Chalkduster; } 注意上面的 CSS 中指定的特殊字体需要根据不同的平台自定义，不是所有的平台都具有相同的字体。 img 注意： Xamarin.Forms 中当前存在一个 bug，在 Windows 中本地 HTML 内容不能被显示，但是它不会影响 Windows Phone。查看 Bugzilla 获取关于这个 bug 最新状态的更多信息。 使用 WebView 显示本地内容，你需要像打开其他文件一样打开一个 HTML 文件，然后读取内容文本到 HtmlWebViewSource 的 Html 属性上。关于打开文件的更多信息，可以查看 Working with Files。 虽然我们读取了第一个页面，但是 WebView 并不知道 HTML 来自于哪里。这样在处理页面引用本地资源时就会有问题。例如，一个本地文件很可能有一个指向另一个文件的链接，也有可能使用一个分离的 JavaScript 文件，或者一个 CSS 样式文件。 为了解决这个问题，你需要告诉 WebView 到文件系统的哪里去寻找文件。此时需要设置 WebView 所引用的 HtmlWebViewSource 对象的 BaseUrl 属性。 因为文件系统在每个操作系统上是不一样的，所以你需要针对每个平台确定它的 URL。Xamarin.Forms 可以通过 DependencyService 解决运行时的平台依赖。 要使用 DependencyService，需要先定义一个可被各平台所实现的接口： public interface IBaseUrl { string Get(); } 注意，该接口需要被各个平台实现，否则 App 会无法运行。在公共项目中，要确保你记得使用 DependencyService 设置 BaseUrl 的值： var source = new HtmlWebViewSource(); source.BaseUrl = DependencyService.Get\u003cIBaseUrl\u003e().Get(); 至此，你只需要在各个平台中实现这个接口就可以了： iOS [assembly: Dependency(typeof(BaseUrl_iOS))] namespace WorkingWithWebview.iOS { public class BaseUrl_iOS : IBaseUrl { public string Get() { return NSBundle.MainBundle.BundlePath; } } } 此时网站的位置会被定位到项目的根目录或者 Resources 目录，并且文件的生成操作应该修改为 BundleResource，如下图： img Android 在 Android 平台下，HTML，CSS 和图片文件应该位于 Assets 文件夹下，并且生成操作应该修改为 AndroidAsset，如下图： img Android 平台下，BaseUrl 的值应该设置为 \"file:///android_asset/\"： [assembly: Dependency(typeof(BaseUrl_Android))] namespace WorkingWithWebview.Android { public class BaseUrl_Android : IBaseUrl { public string Get() { return \"file:///android_asset/\"; } } } Android 平台下，Assets 文件夹下的文件也可以通过 Forms.Context.Assets 属性访问，代码如下： var assetManager = Xamarin.Forms.Forms.Context.Assets; using (var streamReader = new StreamReader(assetManager.Open(\"local.html\"))) { var html = streamReader.ReadToEnd(); } Windows Phone 注意： 在Windows Phone 8.1 下 WebView 不支持本地内容，但是在 Windows Phone 8 下支持。 在 Windows Phone 平台下，HTML，CSS 和图片文件位于项目根目录，并且生成操作应该修改为 Content，如下图： img Windows Phone 平台下，BaseUrl 的值应该设置为\"\"： [assembly: Dependency(typeof(BaseUrl_Windows))] namespace WorkingWithWebview.Windows { public class BaseUrl_Windows : IBaseUrl { public string Get() { return \"\"; } } } ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:1:3","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Navigation WebView 可以通过几个方法和属性来进行导航： GoForward()——如果 CanGoForward 等于 true，调用 GoForward 导航到下一个访问页面。 GoBack()——如果 CanGoBack 等于 true，调用 GoBack 将会导航到最后一个访问过的页面。 CanGoBack——如果有页面可以返回则该值等于 true，如果浏览的是起始 URL 则该值返回 false。 CanGoForward——如果用户返回了某个页面并且可以向前访问某个已经访问过的页面则该值为 true。 在页面内部，WebView 不支持多点触控。所以重点是需要针对移动端优化内容，使其呈现时不需要额外的缩放等操作。 对于应用程序来说，在 WebView 中展示链接比在设备的浏览器中展示更常见。在这种情况下，允许正常的导航非常有用，但是当用户在起始页面点击返回按钮时，程序会返回到一个正常的 App 页面中。 下面演示如何使用内建的方法和属性启用这种场景。 首先在一个 page 页面中创建一个浏览器视图： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.InAppDemo\" Title=\"In App Browser\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cStackLayout Orientation=\"Horizontal\" Padding=\"10,10\"\u003e \u003cButton Text=\"Back\" HorizontalOptions=\"StartAndExpand\" Clicked=\"backClicked\" /\u003e \u003cButton Text=\"Forward\" HorizontalOptions=\"End\" Clicked=\"forwardClicked\" /\u003e \u003c/StackLayout\u003e \u003cWebView x:Name=\"Browser\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台代码： public partial class InAppDemo : ContentPage { //sets the URL for the browser in the page at creation public InAppDemo(string URL) { InitializeComponent(); Browser.Source = URL; } private void backClicked(object sender, EventArgs e) { //check to see if there is anywhere to go back to if (Browser.CanGoBack) { Browser.GoBack(); } else { //if not, leave the view Navigation.PopAsync(); } } private void forwardClicked(object sender, EventArgs e) { if (Browser.CanGoForward) { Browser.GoForward(); } } } 最后呈现效果如下： img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Events WebView 通过触发两个事件来帮助你响应状态变更： Navigating——当 WebView 开始加载一个新页面时触发。 Navigated——当一个页面加载完毕并且导航停止时触发。 如果你能预感到加载网页将会耗费比较长的时间，可以考虑使用这两个事件实现一个状态指示器。代码如下： 界面 XAML 代码： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"WebViewDemo.LoadingDemo\" Title=\"Loading Demo\"\u003e \u003cContentPage.Content\u003e \u003cStackLayout\u003e \u003cLabel x:Name=\"LoadingLabel\" Text=\"Loading...\" HorizontalOptions=\"Center\" isVisible=\"false\" /\u003e \u003cWebView x:Name=\"Browser\" HeightRequest=\"1000\" WidthRequest=\"1000\" Navigating=\"webOnNavigating\" Navigated=\"webOnEndNavigating\" /\u003e \u003c/StackLayout\u003e \u003c/ContentPage.Content\u003e \u003c/ContentPage\u003e 后台两个事件处理： void webOnNavigating (object sender, WebNavigatingEventArgs e) { LoadingLabel.IsVisible = true; } void webOnEndNavigating (object sender, WebNavigatedEventArgs e) { LoadingLabel.IsVisible = false; } 当页面加载中时输出结果如下： img 当页面加载完成时输出如下： img ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Performance 最近的各大 web 浏览器都已经采用了一些被世人所熟知的流行技术，如硬件加速渲染和 JavaScript 编译。不幸的是，出于安全限制，大多数高级功能在 iOS 的 WebView 和 UIWebView 里无法使用。Xamarin.Forms 里的 WebView 在 iOS 平台下实际上是使用的 UIWebView。如果这个限制对你的使用造成了困扰，你需要在平台内部使用支持快速浏览等功能的 WKWebView 进行重新渲染。但是需要注意 WKWebView 仅支持 iOS 8 以上的系统。 WebView 在 Android 的默认设置中跟内建浏览器一样快。 在 Windows Phone 8 和 Windows Phone 8.1 里的 WebBrowser 控件不支持最新的 HTML5 相关新特性，并且它常常出现性能问题。需要注意测试网站在 Windows Phone 的 WebView 中究竟会怎样呈现，如果仅在 IE 浏览器中测试是不够的。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Permissions 为了让 WebView 正常工作，你必须知道各个平台的权限设置。注意在一些平台，WebView 在 debug 模式下可以工作，但是在最后发布时的 release 模式下却不能。这就是权限造成的问题，比如 Android 上的 internet 访问权限，在 Xamarin Studio 的调试模式下默认是打开的。 Windows Phone 8.0——需要 ID_CAP_WEBBROWSERCOMPONENT 权限来使用控件，需要 ID_CAP_NETWORKING 来访问因特网。 Windows Phone 8.1——需要 Internet 才能访问网络内容。 Android——需要 Internet 才能访问网络内容，访问本地内容不需要特殊的权限。 iOS——不需要特殊的权限。 ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"Layout 不像大多数其他 Xamarin.Forms 视图，在 StackLayout 和 RelativeLayout 中嵌套 WebView 时必须指明它的 HeightRequest 和 WidthRequest 属性。如果你没有指明这些属性，那么 WebView 将不会渲染。 下面的例子展示了 WebView 的渲染布局代码： 在 StackLayout 中指明 HeightRequest 和 WidthRequest： \u003cStackLayout\u003e \u003cLabel Text=\"test\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" HeightRequest=\"1000\" WidthRequest=\"1000\" /\u003e \u003c/StackLayout\u003e 在 RelativeLayout 中指明 HeightRequest 和 WidthRequest： \u003cRelativeLayout\u003e \u003cLabel Text=\"test\" RelativeLayout.XConstraint= \"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint= \"{ConstraintExpression Type=Constant, Constant=20}\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" RelativeLayout.XConstraint=\"{ConstraintExpression Type=Constant, Constant=10}\" RelativeLayout.YConstraint=\"{ConstraintExpression Type=Constant, Constant=50}\" WidthRequest=\"1000\" HeightRequest=\"1000\" /\u003e \u003c/RelativeLayout\u003e 在 AbsoluteLayout 中不用指明 HeightRequest 和 WidthRequest： \u003cAbsoluteLayout\u003e \u003cLabel Text=\"test\" AbsoluteLayout.LayoutBounds=\"0,0,100,100\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" AbsoluteLayout.LayoutBounds=\"0,150,500,500\" /\u003e \u003c/AbsoluteLayout\u003e 在 Grid 中不用指明 HeightRequest 和 WidthRequest，Grid 是少数的几个不用指明宽和高的布局容器： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"100\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cLabel Text=\"test\" Grid.Row=\"0\" /\u003e \u003cWebView Source=\"http://www.xamarin.com/\" Grid.Row=\"1\" /\u003e \u003c/Grid\u003e 原文链接： https://developer.xamarin.com/guides/xamarin-forms/user-interface/webview/ 相关 Demo：Working with WebView WebView 的简单演示：WebView WebView 的高级演示，包括平台自定义渲染 WebView 和 JavaScript 和 C# 代码交互： HybridWebView ","date":"2016-03-13","objectID":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms——WebView 技术研究","uri":"/xamarin.formswebview-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"},{"categories":["xamarin"],"content":"如之前所见的大量可视化元素均有自己的尺寸大小： iOS 的状态栏高度为 20，所以我们需要调整 iOS 的页面的 Padding 值，留出这个高度。 BoxView 设置它的默认宽度和高度为 40。 Frame 的默认 Padding 为 20。 StackLayout 的默认 Spacing 属性值为 6。 还有 Device.GetNamedSize 方法，该方法将 Label 或 Button 等控件中使用的 NamedSize 枚举值转换为不同平台对应的数值，即不同控件中不同 NamedSize 枚举对应的 FontSize 值。 然后上面那些数值代表什么？它们的单位是什么？并且怎样精确的设置这些值获得指定的大小？ 好问题。尺寸大小同样会影响文本的显示效果，正如我们所看到，不同的平台显示的文本的数量也会不一样，那么可以在 Forms 程序中控制显示的文本数量吗？即使可以控制，那会是一种好的编程实践吗？程序应该通过调整尺寸大小来适应屏幕的显示密度吗？ 通常，当编写 Xamarin.Forms 应用程序时不要过于接近那些可视化元素的实际尺寸数值。最好的方式是充分信任 Xamarin.Forms 在三个不同平台下都会做出最好的默认选择。 然后，有时一个开发者还是需要知道部分可视化元素的尺寸大小以及它们所附着的屏幕的尺寸大小。 如你平时所知的一样，视频是由一大堆像素所组成的一个矩形。任何可以显示在屏幕上的可视化元素都有一个像素尺寸。在早期的个人电脑中，开发者都用像素来定位和布局那些可视化元素。但是，随着拥有更多元素的大小尺寸和像素密度的显示设备出现，在编写程序时直接使用像素的方式变得过时和不受开发者欢迎了，必须寻求另一种新的解决方案。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:0:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"Pixels，points，dps，DIPs，DIUs 这种控制像素的方式始于桌面电脑时代的操作系统，于是这种解决方案也自然而然的被用于移动设备。因此，我们将从桌面设备开始探讨这个问题。 桌面视频有大量不同的像素尺寸，从几乎要过时的 640x480 到上千像素。跟电影和电视一样，4:3 的纵宽比也曾经是电脑显示的标准，不过现在更常用高清晰纵宽比，如 16：9 或者 16：10。 桌面视频也有一个物理尺寸，这个物理尺寸通常是测量显示器对角线的英寸和厘米长度。通过像素尺寸和物理尺寸可以计算出这个视频的显示分辨率或者像素密度，像素密度使用 DPI（dots per inch 打印分辨率——即每英寸所打印点数）来描述，有时也可以使用 PPI（pixels per inch 图像的采样率——即每英寸的像素数量）。显示分辨率还可以通过 点距（dot pitch——即相邻像素间的距离，毫米为单位）来描述。 例如，使用毕达哥拉斯定律可以计算出一个 800x600 分辨率的对角线长度上可以容纳 1000 像素点，如果是 13 英寸的显示器，那么像素密度是 77 DPI，或者 0.33 毫米的点距。然后，如果现代笔记本上的 13 英寸显示器可能拥有 2560x1600 的像素尺寸，230 DPI 的像素密度，或者 0.11 毫米的点距。那么同样的一个 100 像素的正方形元素在高精度显示器上的大小可能只有老式显示器的三分之一大。 当开发者试图调整可视化元素到正确的大小就像一场战役一样。因此，Apple 和 Microsoft 计划为桌面电脑建立一套机制来允许开发者用一些设备无关的单位来描述视频显示的尺寸而不是直接使用像素。开发者遇到的大多数尺寸规格都能用这一系列的设备独立单位来描述，而操作系统就负责在这些设备独立单位和像素之间进行转换。 在 Apple 的世界里，桌面视频都假设每英寸拥有 72 单位元素。这一数字来源于印刷排版界，在传统的印刷排版里，每英寸大约有 72 个点，但是在数字排版印刷方面，这个点位的精度已经标准化为 1/72 英寸。使用点的数量来描述比直接使用像素更好，开发者能更直观的感受到屏幕上可视化元素和这个大小包括的尺寸点数之间的关系。 在 Microsoft 世界里，一个相似的技术已经成熟，被称为设备无关像素（device-independent pixels DIPs），或者设备无关单位（device-independent units DIUs）。作为一个 Windows 开发者，需要知道该平台下的桌面视频假定拥有一个 96 DIUs 的分辨率，比 72 DPI 高三分之一。 然而，移动设备拥有不同的规则：一个特点就是现代手机的像素密度比桌面设备高出很多。高像素密度意味着文本和其他可视化元素会收缩在一个很小的尺寸空间中。 手机的另一个特点就是比桌面设备或笔记本更贴近人的面部。这也意味着相同的可视化元素如果呈现在手机上，尺寸可以比桌面设备更小。因为手机的物理尺寸比桌面设备更小，所以缩小可视化元素来适应屏幕就变得十分可取。 Apple 继续在 iPhone 上使用 DIUs 来描述点数，直到最近，所有的苹果设备都采用来一种被叫做 Retina 的高清屏解决方案，该方案使单点的像素密度变成原来的两倍。这个规则适用于苹果的几乎所有设备，MacBook Pro，iPad 和 iPhone。直到 iPhone 6 Plus 的出现，将单点的像素密度变成了原来的三倍。 例如，iPhone 4 拥有 3.5 英寸屏幕，640x960 像素显示分辨率，320 DPI 的像素密度。由于单点有两倍的像素密度，所以当应用程序运行在 iPhone4 上当时候，将会在屏幕上呈现 320x480 个点。iPhone 3 有 320x480 的像素显示分辨率，点的数量等于像素的数量，所以，对于一个程序来说，呈现在 iPhone 3 和 iPhone 4 上的大小相同。尽管大小尺寸相同，但是 iPhone 4 上的文本和可视化元素将会显示在一个更高的分辨率之上。 对于 iPhone 3 和 iPhone 4，从屏幕尺寸和点数尺寸的关系上来说，它们拥有比桌面设备每英寸 72 点更大的一个密度，每英寸 160 点。 iPhone 5 拥有一个 4 英寸屏幕，但是它点像素尺寸达到了 640x1136。像素密度和 iPhone 4 一样，对于程序来说，屏幕上点数尺寸为 320x768。 iPhone 6 拥有 4.7 英寸屏幕，像素尺寸为 750x1334。像素密度同样也是 320 DPI，每单位点有两个像素，所以对于程序来说，屏幕上能呈现的点数尺寸为 375x667。 然而，iPhone 6 Plus 拥有 5.5 英寸屏幕，像素尺寸为 1080x1920，像素密度为 400DPI，更高的像素密度意味着一个点上有更多的像素，对于 iPhone 6 Plus，Apple 设定一个点等于三个像素点。给我们的感觉是屏幕的点数尺寸应该是 360x640，但是实际对于程序来说，iPhone 6 Plus 点屏幕点数尺寸是 414x736，每英寸 150 个点。 以上信息总结起来就如下面这个表： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5 英寸 3.5 英寸 4 英寸 4.7 英寸 5.5 英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 Android 也十分相似，只是 Andorid 设备拥有更多的设备尺寸和显示尺寸，但是 Andorid 开发者在工作中通常不关心具体设备，而是关心密度无关像素这个单位（density-independent pixel dps）。像素密度和 dps 之间的关系是，每英寸呈现 160dps，即 Andorid 和 Apple 的单位很相似。 然而 Mircosoft 通过 Windows Phone 带来了一种不同的方式。Windows Phone 7 设备无论它的屏幕分辨率是 320x480（这种分辨率很稀有，可不做讨论）或者是 480x800（通常叫做 WVGA Wide Video Graphics Array），都拥有统一的像素尺寸。Windows Phone 7 程序工作在这种像素单位的基础上。假设一台最平常的 4 英寸 480x800 的 Windows Phone 7 设备，这意味着该设备的像素密度大约是 240DPI。而这是 iPhone 和 Android 设备的 1.5 倍。 当 Windows Phone 8 来临时，出现了很多更大屏幕的设备，768x1280（WXGA Wide Extended Graphics Array），720x1280（720P），1080x1920（1080P）。 对于这三种额外的尺寸，开发者同样使用设备无关的单位。此时，一个内部的缩放机制将会使所有设备在竖屏情况下宽度都呈现 480 像素。对应的比例因子如下表： 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs 尺寸 480x800 480x800 480x853 480x853 Xamarin.Forms 开发者通常使用设备无关的方式来处理手机显示，但是在具体三个平台上也有一些不一样： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 如果将相同物理大小的可视化元素放在三个平台，那么 Windows Phone 平台上看见的大小会比 iOS 和 Android 大 1.5 倍。 VisualElement 类定义了两个属性，Width 和 Height，这两个元素用设备无关的单位来描述 views，layouts 和 pages。这两个属性的初始值被设置为伪值 -1。只有当 page 上的所有元素都已经定位和调整大小完毕这两个属性的值才有效。同样，需要注意 HorizontalOptions 或 VerticalOptions 的默认值是 Fill，这个设置将会让视图尽可能的占据更多的空白地方。 Width 和 Height 的值也可以用来反映一些额外空间值，比如 Padding，设置后的区域会被 view 的 BackgroundColor 属性指定的颜色填充。 VisualElement 定义了一个 SizeChanged 事件，当一个可视化元素的 Width 或 Height 属性发生变化时触发。当 page 对内部的大量元素进行定位和调整大小时会触发一系列事件，SizeChanged 事件就是其中一个。这个构造的过程会在第一次定义这个 page 时出现（通常是在 page 的构造中），而任何一个对布局内容的影响都会使这一过程再次发生，例如将视图添加到 ContentPage 或者 StackLayout 中，或从它们中移除，或者改变可视化元素的大小。 当屏幕尺寸发生改变时同样也会触发新的布局过程，这种情况通常发生在设备在竖屏和横屏之间进行切换的","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"可测量尺寸（Metrical sizes） 这里再一次强调一下三个平台上的英寸和设备无关单位之间的关系： iOS：每英寸 160 单位 Android：每英寸 160 单位 Windows Phone：每英寸 240 单位 下面是尺寸以厘米为单位的情况： iOS：每厘米 64 单位 Android：每厘米 64 单位 Windows Phone：每厘米 96 单位 那么意味着 Xamarin.Forms 程序可以使用以上可测量尺寸来更改可视化元素大小，使用熟悉的英寸或厘米为单位。下面给出一个名叫 MetricalBoxView 的程序来展示这个问题，该程序在屏幕上显示了一个宽大约 1 厘米高大约 1 英寸的 BoxView。 public class MetricalBoxViewPage : ContentPage { public MetricalBoxViewPage() { Content = new BoxView { Color = Color.Accent, WidthRequest = Device.OnPlatform(64, 64, 96), HeightRequest = Device.OnPlatform(160, 160, 240), HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; } } 如果你使用直尺在手机屏幕上测量，你会发现结果跟我们希望的尺寸很接近。 img ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"估计字体大小（Estimated font sizes） Label 和 Button 控件上的 FontSize 属性的类型是 double。FontSize 指的是文本字符从最下面到最上面到高度，也包括该字体对应的标点符号。在大多数情况下，你需要通过 Device.GetNamedSize 方法设置这个属性。该方法允许你使用一系列 NamedSize 相关到枚举值：Default，Micro，Small，Medium，Large。 你也可以使用字体大小的实际数字，但是这么做会引起一个小问题（稍后会谈到这个细节）。在大多数情况下，Xamarin.Forms 通过相同的设备无关单位来表示字体的大小，这意味着你可以基于不同的平台分辨率计算设备无关的字体大小。 例如，假设你想在程序中使用 12 号字体。首先，你必须要知道 12 号字体用于印刷材料或是桌面显示器的效果很好，但是如果用于手机就太大了。 如果移动设备上一英寸有 72 个点，那么 12 号字体大约是六分之一英寸，乘以分辨率的 DPI。结果是 iOS 和 Android 设备大约是 27 设备无关单位，Windows Phone 大约是 40 设备无关单位。 我们写一个名叫 FontSizes 的小程序，开头部分与第三章中的 NamedFontSizes 程序很相似，后面还列出了不同字体的点数大小，使用设备点分辨率转换为设备无关单位。 public class FontSizesPage : ContentPage { public FontSizesPage() { BackgroundColor = Color.White; StackLayout stackLayout = new StackLayout { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; // Do the NamedSize values. NamedSize[] namedSizes = { NamedSize.Default, NamedSize.Micro, NamedSize.Small, NamedSize.Medium, NamedSize.Large }; foreach (NamedSize namedSize in namedSizes) { double fontSize = Device.GetNamedSize(namedSize, typeof(Label)); stackLayout.Children.Add(new Label { Text = String.Format(\"Named Size = {0} ({1:F2})\", namedSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } // Resolution in device-independent units per inch. double resolution = Device.OnPlatform(160, 160, 240); // Draw horizontal separator line. stackLayout.Children.Add( new BoxView { Color = Color.Accent, HeightRequest = resolution / 80 }); // Do some numeric point sizes. int[] ptSizes = { 4, 6, 8, 10, 12 }; foreach (double ptSize in ptSizes) { double fontSize = resolution * ptSize / 72; stackLayout.Children.Add(new Label { Text = String.Format(\"Point Size = {0} ({1:F2})\", ptSize, fontSize), FontSize = fontSize, TextColor = Color.Black }); } Content = stackLayout; } } 为便于在三个平台上面比较，背景已被统一设置为白色，文字设置为黑色。在 StackLayout 中间用一个高 1/8 英尺的 BoxView 将两部分分隔开。 这个程序提供了一个粗略的思路让你能够在三个平台上产生视觉上差不多大小的元素。括号中的数字是特定平台下的设备无关的 FontSize 数值。 img 然而在 Android 平台下有一个问题，运行 Android 的 Settings，进入 Display 页面，选择 Font size 项，可以看到，有 Small，Normal（默认），Large，Huge 这几个字号选择。这项设置可以给用户提供更广的字号选择，对于那些觉得字体太小感觉眼睛不舒服的用户可以将字号调大，对于那些眼睛很好想一次多看一些字的用户可以将字号设小。 在设置中修改字号，选择除 Normal 外的其他选项，然后重新运行 FontSizes 程序，可以看到程序里的所有文本都不一样里，根据你的设置，文本比之前都更大或更小了。你可以看到在水平线的上面部分，也就是 Device.GetNamedSize 方法返回的数值根据系统字号的不同发生了变化。对于 NamedSize.Default，Normal 的默认设置返回的字号是 14（就如上面的截图所展示的一样），如果设置为 Small 则返回 12，Large 返回 16，Huge 返回 18.33。 除了 Device.GetNamedSize 返回的值不一样以外，根据字号设置的不同，底层文本绘制的逻辑也不一样。继续看程序的下面部分，程序计算出的字体的点位值依然相同，虽然它们的文本大小已经发生了改变。这是用枚举值设置 Android 的 Label 的结果，Android 在内部会使用 ComplexUnitType.Sp（COMPLEX_UNIT_SP）计算字体大小，SP 代表缩放像素 scaled pixel，当文本超过使用的设备无关像素时会产生一个缩放。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"调整文本到合适的尺寸（Fitting text to available size） 也许你需要调整一堆文本到一定大小的矩形区域，你可以使用两个数值来计算，一个是矩形区域的实际尺寸，另一个是装载这些文本的 Label 控件的 FontSize 属性值（但是 Andorid 需要将 Font size 设置为 Normal）。 第一个需要的数值是行距，即 Label 视图里每一行文本间的垂直高度。下面展示了三个平台下的具体行高值： iOS：行距 = 1.2 * label.FontSize Android：行距 = 1.2 * label.FontSize Windows Phone：行距 = 1.3 * label.FontSize 第二个有帮助的数值是字符宽度，不管在哪个平台，一段混合了大小写的默认字体的字符宽度大约是 font size 的一半： 平均字符宽度 = 0.5 * label.FontSize 例如，假设你想在宽度为 320 的长度内容纳 80 个文本字符，并且你想让字体尽量的大。那么 320 除以 40（宽度大约占高度一半）得到字号为 8，这个数值就是我们可以给 Label 的 FontSize 属性赋的值。对于文本来说在真正测试之前还有一些不确定性，希望不要对你的计算结果产生太多惊喜。 下面这个程序展示了如何让行距以及字符宽更适合页面中的一段文本，当然这个页面是不包括 iPhone 的状态栏的。为了让 iPhone 排除状态栏更容易一些，这个程序使用了 ContentView。 ContentView 继承自 Layout，只添加了一个 Content 属性。ContentView 是 Frame 的基类，但是 Frame 没有添加过多的额外功能。然而，当你想在自定义页面中定义一组视图，并轻松的模拟它们间的外边距，它将变得很有用。 也许你注意到了，Xamarin.Forms 没有一个 margin 的概念，跟 padding 很相似，padding 定义了视图里的内边距，而 margin 定义了视图外面的外边距。ContentView 可以让我们模拟这个，如果你发现一个视图需要一个外边距，那么你可以将这个视图放在 ContentView 中，并且设置这个 ContentView 的 Padding 属性。ContentView 的 Padding 属性继承自 Layout。 这个 EstimatedFontSize 程序使用 ContentView 的方式略有不同：它通过设置整个页面的 padding 来避开 iOS 的状态栏，而不是将页面中的某一项内容设置到 ContentView 中。因此，此处的 ContentView 除了 iOS 的状态栏以外与页面有相同的尺寸。通过附加 ContentView 的 SizeChanged 事件来获取内容区的尺寸，通过这个尺寸来计算文本的字号。 SizeChanged 事件的处理方法中使用了第一个参数，这个参数通常是引发这次事件的对象（在这个程序里就是包含那个文本填充的 ContentView），代码如下： public class EstimatedFontSizePage : ContentPage { Label label; public EstimatedFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { string text = \"A default system font with a font size of S \" + \"has a line height of about ({0:F1} * S) and an \" + \"average character width of about ({1:F1} * S). \" + \"On this page, which has a width of {2:F0} and a \" + \"height of {3:F0}, a font size of ?1 should \" + \"comfortably render the ??2 characters in this \" + \"paragraph with ?3 lines and about ?4 characters \" + \"per line. Does it work?\"; // Get View whose size is changing. View view = (View)sender; // Define two values as multiples of font size. double lineHeight = Device.OnPlatform(1.2, 1.2, 1.3); double charWidth = 0.5; // Format the text and get its character length. text = String.Format(text, lineHeight, charWidth, view.Width, view.Height); int charCount = text.Length; // Because: // lineCount = view.Height / (lineHeight * fontSize) // charsPerLine = view.Width / (charWidth * fontSize) // charCount = lineCount * charsPerLine // Hence, solving for fontSize: int fontSize = (int)Math.Sqrt(view.Width * view.Height / (charCount * lineHeight * charWidth)); // Now these values can be calculated. int lineCount = (int)(view.Height / (lineHeight * fontSize)); int charsPerLine = (int)(view.Width / (charWidth * fontSize)); // Replace the placeholders with the values. text = text.Replace(\"?1\", fontSize.ToString()); text = text.Replace(\"??2\", charCount.ToString()); text = text.Replace(\"?3\", lineCount.ToString()); text = text.Replace(\"?4\", charsPerLine.ToString()); // Set the Label properties. label.Text = text; label.FontSize = fontSize; } } 这段文本中可以看到唯一名称为“?1”，“??2”，“?3”和“?4”的占位符，程序运行中会用文本的信息替换掉这些占位符。 如果我们的目标是让文本尽量的大但是又不会溢出一屏的范围，那么结果会跟下面的图很接近： img 效果不错，虽然 iPhone 和 Android 实际上只显示了 14 行文本，但技术看起来还是可靠的。我们没必要让横屏模式计算出的 FontSize 值也相等，但有时候它也确实可以做到： img ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"一个大小合适的计时器（A fit-to-size clock） Class 类中包含一个静态 StartTimer 方法让你能够设置一个计时器定期触发事件。这个可用的周期性事件可以保证这个计时器应用可行，虽然这个应用只是简单的展示一个时间文本。 此处 Device.StartTimer 方法的第一个参数使用一个 TimeSpan 类型的值表示一个时间间隔，这个时间间隔直接影响计时器的触发周期（你的设置可以低到 15 或 16 毫秒，大概等于每秒 60 帧的显示器的帧速率周期），计时器的事件处理函数没有参数，但是需要返回 true 让计时器继续。 程序 FitToSizeClock 创建了一个 Label 用于显示时间然后设置了两个事件：页面的 SizeChanged 事件用于改变字号，Device.StartTimer 事件用于每秒钟改变时间文本值。两个事件的处理代码都是只需要简单的改变 Label 的一个属性，所以可以使用 lambda 表达式来简化写法，就不需要将 Label 存成字段，直接在 lambda 表达式里就直接访问。 public class FitToSizeClockPage : ContentPage { public FitToSizeClockPage() { Label clockLabel = new Label { HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center }; Content = clockLabel; // Handle the SizeChanged event for the page. SizeChanged += (object sender, EventArgs args) =\u003e { // Scale the font size to the page width // (based on 11 characters in the displayed string). if (this.Width \u003e 0) clockLabel.FontSize = this.Width / 6; }; // Start the timer going. Device.StartTimer(TimeSpan.FromSeconds(1), () =\u003e { // Set the Text property of the Label. clockLabel.Text = DateTime.Now.ToString(\"h:mm:ss tt\"); return true; }); } } 在 StartTimer 的方法中指定了一个 DateTime 的自定义格式化字符串将文本格式化为一段 10 个或 11 个的文本字符，文本都是大写字符，并且宽度比平均宽度更宽。在 SizeChanged 处理函数中隐藏了一个逻辑，即假设要显示的文本字符数为 12 个，那么设置它的字号应该是页面宽度的 1/6： img 当然，在横屏模式下文本会变得更大： img 再次提醒，该技术在 Android 平台下只能用于系统设置中 Font size 的值设置为 Normal 的情况。 ","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["xamarin"],"content":"凭经验使用恰当的文本（Empirically fitting text） 在一个特定的矩形框大小范围内填充合适的文本的另一个解决方法是：先凭经验设置文本的字号，然后在此基础上再调大或调小。该方法的优点是在 Android 设备上无论用户系统设置中的 Font size 是什么，都可以很好的工作。 但这个过程可能比较棘手：第一个问题是在字体大小和渲染文本的高度上没有一个清晰的线性关系。当文本在它的容器中宽度越大时，它在单词间就越容易出现分行，这种情况会造成更多的空间浪费。所以为了找到最佳字号往往会重复多次计算。 第二个问题涉及到 Label 渲染一个指定大小字号的文本时，获取 Label 尺寸的一个机制。你可以处理 Label 的 SizeChanged 事件，但是在处理函数里你不能做任何改变（如设置一个新的 FontSize 属性），因为这样做会引起这个事件处理函数的递归调用。 一个更好的方式是调用 GetSizeRequest 方法，这个方法定义在 VisualElement 类中， Label 和其他所有视图元素都继承自这个类。GetSizeRequest 方法需要两个参数，一个是宽度的限制，另一个是高度的限制。这两个值可以表示一个矩形范围，以此来限制你想让这个元素填充的一个范围，并且这两个值可以部分或全部都定义为无穷大。当调用 Label 的 GetSizeRequest 方法时，通常可以将宽度限制为 Label 元素容器的宽度，高度设置为 Double.PositiveInfinity。 GetSizeRequest 方法返回一个类型为 SizeRequest 的值，该类型为一个结构体，定义了两个属性 Minimum 和 Request，两个属性的类型都为 Size。Request 属性指出了这段渲染文本的尺寸大小（关于此类容更多的内容会在后面的章节讲到）。 下面的程序 EmpiricalFontSize 证明了这项技术。为了方便，定义了一个名叫 FontCalc 的结构体来专门针对特定的 Label（已初始化文本）、字号和文本宽度调用 GetSizeRequest 方法： struct FontCalc { public FontCalc(Label label, double fontSize, double containerWidth) : this() { // Save the font size. FontSize = fontSize; // Recalculate the Label height. label.FontSize = fontSize; SizeRequest sizeRequest = label.GetSizeRequest(containerWidth, Double.PositiveInfinity); // Save that height. TextHeight = sizeRequest.Request.Height; } public double FontSize { private set; get; } public double TextHeight { private set; get; } } 这段代码将渲染后的 Label 元素的高度存储在一个 TextHeight 属性中。 当你对一个 page 或是 layout 调用 GetSizeRequest 方法时，它们必须要获得所有包含在可视化树中的元素的尺寸大小。当然，这是有性能损失的，所以，除非有特别的必要，你应该尽量避免这样做。但是 Label 元素没有子元素，所以对 Label 调用 GetSizeRequest 方法的影响并不大。然而，你依然应该尽量尝试优化这个调用。尽量避免通过循环一列字号来找出那个不会导致文本溢出容器的最大字号值，能通过算法来找出合适的值那才更好。 GetSizeRequest 方法需要被调用的元素是可视化树的一部分，并且布局过程至少应该部分开始了。不要在 page 类的构造函数中调用 GetSizeRequest 方法，你不会从中获得任何信息。第一个可能获取到返回信息的时机是 OnAppearing 的重载方法。当然，此时你可能没有足够的信息给 GetSizeRequest 方法提供参数。 在 EmpiricalFontSizePage 类中，Label 的承载容器 ContentView 的 SizeChanged 事件处理函数中有使用 FontCalc 值的实例。（这里的事件处理函数与 EstimatedFontSize 程序相似）。每个 FontCalc 的构造函数对 Label 调用了 GetSizeRequest 方法并将结果存放在 TextHeight 中。SizeChanged 的处理函数在 10 和 100 的上下限字号之间尝试最佳值。因此变量的名称是 lowerFontCalc 和 upperFontCalc： public class EmpiricalFontSizePage : ContentPage { Label label; public EmpiricalFontSizePage() { label = new Label(); Padding = new Thickness(0, Device.OnPlatform(20, 0, 0), 0, 0); ContentView contentView = new ContentView { Content = label }; contentView.SizeChanged += OnContentViewSizeChanged; Content = contentView; } void OnContentViewSizeChanged(object sender, EventArgs args) { // Get View whose size is changing. View view = (View)sender; if (view.Width \u003c= 0 || view.Height \u003c= 0) return; label.Text = \"This is a paragraph of text displayed with \" + \"a FontSize value of ?? that is empirically \" + \"calculated in a loop within the SizeChanged \" + \"handler of the Label's container. This technique \" + \"can be tricky: You don't want to get into \" + \"an infinite loop by triggering a layout pass \" + \"with every calculation. Does it work?\"; // Calculate the height of the rendered text. FontCalc lowerFontCalc = new FontCalc(label, 10, view.Width); FontCalc upperFontCalc = new FontCalc(label, 100, view.Width); while (upperFontCalc.FontSize - lowerFontCalc.FontSize \u003e 1) { // Get the average font size of the upper and lower bounds. double fontSize = (lowerFontCalc.FontSize + upperFontCalc.FontSize) / 2; // Check the new text height against the container height. FontCalc newFontCalc = new FontCalc(label, fontSize, view.Width); if (newFontCalc.TextHeight \u003e view.Height) { upperFontCalc = newFontCalc; } else { lowerFontCalc = newFontCalc; } } // Set the final font size and the text with the embedded value. label.FontSize = lowerFontCalc.FontSize; label.Text = label.Text.Replace(\"??\", label.FontSize.ToString(\"F0\")); } } 在 while 循环的每一次迭代中，根据两个 FontCalc 值的平均值获取 Fontsize 的值并且获取一个新的 FontCalc 对象。依据渲染文本的高度用这个新对象来设置 lowerFontCalc 或者 upperFontCalc。当字体大小计算出最佳值时，循环结束。 大约七次循环之后，就能得到一个比之前那个程序估算出的值更合适的值： img 旋转手机就能触发另一次重算，计算出的字号跟刚才相似（虽然没必要一样）： img 似乎该算法通过 FontCalc 作为上下限能计算出更大平均值的字号。但是字号和渲染文本之间的高度过于复杂，有时最简单的方式得到的结果也一样的","date":"2016-03-06","objectID":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms ——尺寸大小（五 Dealing with sizes）","uri":"/xamarin.forms-%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%BA%94-dealing-with-sizes/"},{"categories":["dotnet"],"content":"在 .Net 4 中，Task.Factory.StartNew是启动一个新Task的首选方法。它有很多重载方法，使它在具体使用当中可以非常灵活，通过设置可选参数，可以传递任意状态，取消任务继续执行，甚至控制任务的调度行为。所有这些能力也带来了复杂性的提升，你必须知道何时应该使用何种重载方法，提供哪种调度方式等等。并且Task.Factory.StartNew这种写法也不够简洁明快，至少对它使用的主要场景不够快，一般它使用的主要场景只是将一个工作任务丢给一个后台线程执行而已。 于是，在 .NET Framework 4.5 开发者预览版 中，微软引进了新的Task.Run方法。新方法不是为了替代旧的Task.Factory.StartNew方法，只是提供了一种使用Task.Factory.StartNew方法的更简洁的形式，而不需要去指定那一系列参数。这是一个捷径，事实上，Task.Run的内部实现逻辑跟Task.Factory.StartNew一样，只是传递了一些默认参数。比如当你使用Task.Run： Task.Run(someAction); 实际上等价于： Task.Factory.StartNew(someAction, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 使用这些默认参数，Task.Run就能用于大多数情况——只是将任务简单的交给后台线程池去执行（这也是使用TaskScheduler.Default参数的目标）。这也并不意味着Task.Factory.StartNew方法就不必再使用了，它仍然有很多重要的用处。你可以通过控制TaskCreationOptions参数来控制任务的行为，你也可以通过控制TaskScheduler来控制任务应该如何排队如何运行，你也可以使用重载方法中的接受对象状态那个参数，对于一些性能敏感的代码，它可以用于避免闭包以及相应的资源分配。不过对于上面那个简单的例子，Task.Run是最友好。 Task.Run提供了八种重载方式，用于提供下面这几种组合情况： 普通任务（Task）和带返回值任务（Task\u003cTResult\u003e） 可取消任务（Cancelable）和不可取消任务（non-cancelabl） 同步委托（Synchronous）和异步委托（Asynchronous） 前两个很明显，对于第一点如果是用的Task做返回值的重载方法，那么该任务就没有返回值，如果是用的Task\u003cTResult\u003e做返回值的重载方法，那么该任务就有一个类型为TResult的返回值。对于第二点，也有接受CancellationToken参数的重载，可以在任务开始之前执行取消操作，然后并行任务（Task Parallel Library——TPL）就可以自然的过度到取消状态。 第三点要更有趣一些，它直接关系到 Visual studio 11 中的 C#和 Visual Basic 的异步语言支持。我们先使用Task.Factory.StartNew来展示下这个问题，如果有下面一段代码： var t = Task.Factory.StartNew(() =\u003e { Task inner = Task.Factory.StartNew(() =\u003e {}); return inner; }); 这里t的类型会被推断为Task\u003cTask\u003e，因为此处任务的委托类型是Func\u003cTResult\u003e，所以这里TResult的类型就是Task，于是StartNew方法就返回Task\u003cTask\u003e，类似的，我可以改变成下面这种写法： var t = Task.Factory.StartNew(() =\u003e { Task\u003cint\u003e inner = Task.Factory.StartNew(() =\u003e 42)); return inner; }); 此处的t的类型自然是Task\u003cTask\u003cint\u003e\u003e，任务的委托类型还是Func\u003cTResult\u003e，TResult的类型就是Task\u003cint\u003e，StartNew方法就返回Task\u003cTask\u003cint\u003e\u003e。这有什么关系呢？考虑下如果我们现在使用下面这种写法： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }); 这里使用了async关键词，编译器会将这个委托映射成Func\u003cTask\u003cint\u003e\u003e，调用这个委托最终会返回Task\u003cint\u003e。因为这个这个委托是Func\u003cTask\u003cint\u003e\u003e，TResult的类型就是Task\u003cint\u003e，所以最后t的类型应该是Task\u003cTask\u003cint\u003e\u003e，而不是Task\u003cint\u003e。 为了应对这几种情况，在 .Net 4 中引入了Unwrap方法。Unwrap方法有两种重载形式，均是扩展方法的形式，一种是针对类型Task\u003cTask\u003e，另一种是针对\u003cTask\u003cTResult\u003e\u003e。微软只所以要把这个方法命名为解包（Unwrap），是因为这个方法可以返回任务的实际结果。对Task\u003cTask\u003e调用Unwrap方法可以返回一个新的Task（就像内部任务的一个代理一样）代表它的内部任务。相似的，对Task\u003cTask\u003cTResult\u003e\u003e调用Unwrap返回一个新的Task\u003cTResult\u003e代表它的内部任务。但是，如果外部任务失败了或者取消了，就不会有内部任务了，因为没有任务运行完成，所以代理任务也就变成了外部任务的状态。回到前面的例子，如果想让t代表内部任务的返回值（在这个例子中，这个值是 42），那么应该像下面这样写： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }).Unwrap(); 现在，变量t的类型是Task\u003cint\u003e，代表异步调用的结果。 现在回到Task.Run，因为微软想让开发者尽可能的使用这个方法来启用后台任务，并且可以配合async/await使用，所以微软决定在Task.Run方法中内建unwrapping的功能。这也是上面第三点所指的内容，Task.Run的重载方法中有可以接受Action（没有返回值的任务）的，有接受Func\u003cTResult\u003e（返回TResult的任务）的，有接受Func\u003cTask\u003e（返回一个异步任务的任务）的，还有接受Func\u003cTask\u003cTResult\u003e\u003e（返回一个带TResult类型返回值的异步任务的任务）的。总的来说，Task.Run方法提供了上面Task.Factory.StartNew方法相同的unwrapping操作。于是，我们可以这样写： var t = Task.Run(async delegate { await Task.Delay(1000); return 42; }); t的类型是Task\u003cint\u003e，此处Task.Run执行的重载方法等价于： var t = Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 如前所述，这是一个快捷方式。 上面讲的全部类容都意味着你可以使用Task.Run调用标准的lambdas/anonymous方法或是异步lambdas/anonymous方法，最后总会按你所期望的行为运行。如果我们想让任务在后台运行并且想等待它的结果，那么可以像下面这样写： int result = await Task.Run(async () =\u003e { await Task.Delay(1000); return 42; }); 此处变量result的类型正是你所期望的int，并且在该任务被调用大约 1 秒钟后，变量result的值被设置为 42。 有趣的是，新的await关键字被认为是等价于Unwrap方法的一种新语法形式。于是，如果我们回到上面那个Task.Factory.StartNew例子，我们可以先用Unwrap重写上面那个代码片段： int result = await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default).Unwrap(); 或者，可以使用第二个await替换Unwrap： int result = await await Task.Factory.StartNew(async delegate { await Task.Delay(1000); return 42; }, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default); 这里的await await虽然看着别扭，但是并没有问题。Task.Factory.StartNew方法返回一个Task\u003cTask\u003cint\u003e\u003e，对Task\u003cTa","date":"2016-03-05","objectID":"/task.run-vs-task.factory.startnew/:0:0","tags":["dotnet","async","translation"],"title":"Task.Run Vs Task.Factory.StartNew","uri":"/task.run-vs-task.factory.startnew/"},{"categories":["xamarin"],"content":"Xamarin 介绍 Xamarin 是一套跨平台解决方案，目的是使用 C# 语言创造原生的 iOS，Android，Mac 和 Windows 应用。 Xamarin 的三个优势： Xamarin App 拥有原生 App 的性能，因为最后生成的 App 中是使用的原生的控件和原生的 API，所以它的体验和效率与原生 App 相近。 使用熟悉的 C# 语法，在 Objective-C，Swift 或者 Java 中能做的任何事情都可以用 C# 做到。除此之外，C# 还有强大的 IDE 智能提示，lambdas 语法，更自然的异步语法（Task、Async），NuGet 快速获取组件。 在不同的平台上使用同样的语言还具有共享代码的优势，各个平台大约可以共享 75% 的 APIs 和数据结构代码。如果使用 Xamarin.Forms 来创建UI几乎可以共享 100% 的代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"最终的思想，共享代码 说白了，Xamarin 宣称的最大的优势就是在三个平台上使用同一种语言来共享代码，总体说来有三种技术实现： Shared Projects：可以在里面添加供三个平台公用的代码，图片和多媒体文件等，代码部分可使用#if __ANDROID__等条件编译符来指定哪一部分会编译输出到特定平台中。 Portable Class Libraries(PCLs)：使用更多的还是 PCLs，PCLs 库直接就能被各个平台所引用，一些流行的库如 SQLite，Json.NET,ReactiveUI 都支持 PCL。 Xamarin.Forms：支持你用 C# 代码来创建在三个平台上共享的 UI 界面，总共可以使用超过 40 个控件，它们都会在运行时映射为原生控件。 共享代码的关系就如下图： 共享代码的关系 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 安装指南 工欲善其事，必先利其器。Xamarin的安装过程参考简书上的一篇文章，内容很齐全很详细：http://www.jianshu.com/p/c67c14b3110c 由于墙的原因，从官网下载的安装包无法直接安装，可以通过安装包中解析出配置文件，从中获取下载路径： Windows下载路径 Mac下载路径 Windows下的大体流程如下： Visual Studio 肯定是需要的，推荐 VS2013 安装 jdk，修改环境变量 安装 Android SDK，需要修改为国内镜像 安装 NDK 安装 GTK 安装 Xamarin.VisualStudio 安装 XamarinStudio（可选） 注意 6 和 7 的版本号很重要，必须要跟 Mac 端相匹配，跟破解补丁的版本也需要匹配。如果以后升级，通常只需要更新 6 和 7 就可以了。 关于 Android 模拟器，之前折腾过不少，最后推荐一款专用于游戏玩家的 Andorid 模拟器，海马玩模拟器，它的性能很好很流畅，不过游戏模拟器屏幕默认是横屏的，第一次要手动改成竖屏。 Mac 下的大体流程： 如果只考虑用 Mac 开发 iOS 程序，不考虑在 Mac 下开发 Android 程序，那么大体流程如下: 安装 MonoFramework 安装 monotouch 安装 XamarinStudio 需要注意三者之间的版本一一对应。 关于商业证书，Xamarin 的价格是很昂贵的： 价格 上面看到的价格只是针对单用户单设备平台，通常我们使用 Xamarin 都希望至少能用于 Android 和 iOS 两个平台，所以价格还得乘以 2。 安装完毕后如果没有购买商业证书，那么可以按照上面那篇文章来破解试用，如果使用的版本号在 3.11 之前，那么只需要完成离线破解，IDE 不需要登陆 Xamarin 账号，如果版本号在 3.11 之后，而且要编译 iOS（目的是为了连接 Mac 端的 BuildHost，如果是在 Mac 上开发编译 iOS 则不需要），那么还需要完成在线破解，具体破解流程文章里有，大体流程如下，最后提醒一下试用完了别忘了购买官方的商业授权。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"离线破解流程 软件读取机器特征码； 将特征码通过邮件发给破解者，等待他回复授权证书，不付费证书有效期 1 个月，付费 20 元证书有效期 10 年； 将证书和对应版本的破解文件拷贝到指定目录。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"在线破解流程 邮件申请开通在线服务 修改 host 的 IP 地址 导入 SSL 证书 登陆 Xamarin 账号 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 程序结构 程序结构 程序的目录结构大致就可以参考这个图，最顶上一层表示三个特定平台的工程，第二层表示一个 PCL 或者 SAP 工程，通常也是 Forms 所在的工程，然后引用两个核心库 Xamarin.Forms.Core 和 Xamarin.Forms.Xaml，然后特定平台的工程还要引用两个特定平台的库，这个特定平台的库可以让程序集使用特定平台的 API。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方 Demo Xamarin 提供了很多学习用的 Demo，地址是：https://developer.xamarin.com/samples-all/。不过官网的网速确实太慢，在 GitHub 上还有更多更全的 Forms 的 Demo：https://github.com/xamarin/xamarin-forms-samples。 其中我认为几个比较重要的 Demo 可以学习一下： CustomRenderers：教你怎样重写Forms里的一些原生控件的样式； Forms2Native：教你怎样从Forms页面跳转到Native页面； Native2Forms：教你怎样从Native页面跳转回Forms页面； FormsGallery：里面有几乎全部的Forms控件展示； Navigation：教你Forms的App页面导航跳转是怎么回事； UsingDependencyService：教你使用依赖服务在Forms里调用Native的方法； XamFormsImageResize：教你图片尺寸相关的东西； ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin.Forms 官方文档 Xamarin 官方提供了一套很全的在线学习指南，地址是：https://developer.xamarin.com/guides/xamarin-forms/getting-started/，这份指南目录结构良好，便于快速查看，从怎样开始第一个程序到后面怎样到商城发布一应俱全。 还有一个学习途径就是官网教材，可以免费下载离线版：https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/，教材的随书 Demo 地址：https://github.com/xamarin/xamarin-forms-book-preview-2。这本教材支持 Forms1.3 以上，并且章节一直在保持更新，截至 2016/02/25 已发布到 24 章，Demo 的核心库已更新到 2.0 并且加入了 UWP 工程。 如果说在线学习指南可以帮助你快速入门，那么这本教程可以帮助你更细化的理解 Forms 程序。 下面我将 24 章的官方教材的目录做个简单介绍，后面有时间也会对重要的几章做个更详尽的剖析： How Does Xamarin.Forms Fit In?（Forms适合什么场景） Anatomy of an App（剖析一个FormsApp） Deeper into Text（深入文本） Scrolling the Stack（滚动面板） Dealing with Sizes（处理尺寸大小） Button Clicks（按钮点击） XAML vs. Code（创建UI的两种方式） Code and XAML in Harmony（XAML和代码的协调合作） Platform-Specific API Calls（平台特定的API调用） XAML Markup Extensions（XAML扩展标记语言介绍） The Bindable Infrastructure（绑定的基础知识） Styles（样式） Bitmaps（位图） Absolute Layout（绝对布局） The Interactive Interface（交互控件） Data Binding（数据绑定） Mastering the Grid（熟练掌握Grid布局） MVVM（数据绑定开发模式Mvvm讲解） Collection Views（集合控件讲解–List） Async and File I/O（异步I/O操作文件） Transforms（变换—缩放、定位等） Animation（动画） Triggers and Behaviors（触发器和行为） Page Navigation（页面导航） 其中我感觉有几章比较重要，如果对 Xaml（WPF 主要用的界面标记语言）开发不太熟悉的同学需要看一下这几章： 7.XAML vs. Code：了解 Xaml 和 Code 两种方式来创建 UI 界面 8.Code and XAML in Harmony：了解 XAML 和后台代码如何协同工作 10.XAML Markup Extensions：了解扩展标记语言 11.The Bindable Infrastructure：了解绑定的基础知识 16.Data Binding：更深入的了解数据绑定 18.MVVM：了解基于数据绑定的 UI 开发模式 Mvvm 要对Forms的细节有深入理解看下面几章： 3.Deeper into Text：深入理解文本 5.Dealing with Sizes：深入理解如何处理尺寸大小，重点也是拿文本举例，教你如何理解移动开发里面像素、物理尺寸（英尺、厘米）、DPI、DIU，主要思想反正就是不要去关注表示大小的那些数值，字体应该使用字体枚举，布局应该是用比例去控制，要充分相信 Xamarin 平台能帮你控制好大小尺寸。 13.Bitmaps：了解怎样在 Forms 中使用图片，也是满满的都是坑，显示在界面上的图片体积一定要尽量的小，不要将一张原始尺寸的图片加载成缩略图然后放在列表中显示，否则程序一定会内存溢出，一定要对图片进行裁剪，将适合的体积的图片用在适合的地方。从这一章中还可以学习图片在具体平台下的用法和差异等。 19.Collection Views：了解集合控件，列表在 App 当中用得非常普遍，所以应当着重了解。 Async and File I/O：在 Xamarin 中只能使用异步 IO（或者说是 PCL 中只能使用异步IO），从趋势看未来的 .Net Core 可能也只支持异步 IO、异步 Http 请求等，感觉这种更重视性能的 IO 思想是未来框架的趋势，所以可以借此熟悉一下，C# 的异步语法应该算是众多编程语言中的佼佼者了。 下面对第五章 Dealing with Sizes 稍作讲解，这章重点介绍了移动平台下尺寸相关的一些知识，先看下下面两个表格： 型号 iPhone 2，3 iPhone 4 iPhone 5 iPhone 6 iPhone 6 Plus 像素尺寸 320x480 640x960 640x1136 750x1134 1080x1920 屏幕尺寸 3.5英寸 3.5英寸 4英寸 4.7英寸 5.5英寸 像素密度 165 DPI 330 DPI 326 DPI 326 DPI 401 DPI 单位点包含像素数量 1 2 2 2 3 点数尺寸 320x480 320x480 320x568 375x667 414x736 每英寸包含点数量 165 165 163 163 154 屏幕类型 WVGA WXGA 720P 1080P 像素尺寸 480x800 768x1280 720x1280 1080x1920 缩放比例 1 1.6 1.5 2.25 DIUs尺寸 480x800 480x800 480x853 480x853 第一张图是 iPhone 下的一些尺寸元素间的关系，第二张是 WinPhone 的，这里没有给出 Android 的，其实 Android 整体上说来跟 iPhone 的那些参数很相似。 Forms 中真正使用的不是像素，而是点数，点里面包含的像素数量是不一致的，像 iPhone2，3 基本上是一一对应，一个点包含一个像素，iPhone4，5，6 就是两倍像素，iPhone6Plus 就是三倍像素，所以 iPhone 的图片里出现 @2x，@3x 这些标识就是对应平台所使用的像素不同的图片。我们在 Forms 中使用的那些表示宽高的值就是这种点数单位，要知道设置的这些值可以获取整个页面的 Width 和 Height 值。 下面说下字号，Forms 提供了几种枚举字号：Default，Micro，Small，Medium，Large，在不同的设备，不同的用户系统字号设置，不同的控件中，相同的枚举返回的字号数值可能都不一样。通过 Device.GetNamedSize 方法获取的 FontSize 值的单位是 double，表示文本字符从最下面到最上面到高度，字体的宽度一般都是 FontSize 值的一半，字体的行距一般是 FontSize 值的 1.2 倍。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Forms 中 UI 布局细节 在 Forms 中设计各种元素布局等细节依然可以参考设计网页采用的盒模型的思想。从大的块元素的分离到小如一个文字，都可以想象成一个个小盒子。由内容区，内边距，边框，外边距组成。 UI Forms 中还有几个比较容易混淆的类：ContentView，Frame，BoxView。 虽然可以按照盒模型的思想来布局元素，但是 Forms 中没有标准的 margin 的概念，Forms 的做法是在一个内容视图外面再嵌套一个 ContentView，ContentView 继承自 Layout，只多了一个 Content 属性来存放内容视图。此时，ContentView 的 Padding 属性就可以想象成盒子的 Margin。 Frame 在布局中也比较常用，通常用于定义页面中一组视图的区块，它继承自 ContentView，多了些边框、阴影等属性。 BoxView 是一个矩形填充区，在 Forms 中用得最多的地方就是用它来绘制横线、竖线等分割线。虽然看起来很山寨，但它却是是 Forms 中的一个标准用法。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"APP 的发布 前面教程重点是介绍 Xamarin.Forms 相关的东西，对于平台特定的那些没有做介绍，比如平台和 Forms 之间的交互（依赖注入，前面的 Demo 介绍 PPT 有），比如最后 APP 的发布，发布相关的东西参考前面提到的在线教程： ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Android 发布教程 我们项目中的 Android 安装包没有发布进商城，是通过网址直接下载，所以发布教程没有验证：https://developer.xamarin.com/guides/android/deployment,_testing,_and_metrics/publishing_an_application/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:1","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"iOS 发布教程 iOS 需要发布，流程主要是有很多和 apple 打交道的地方比较麻烦，比如说开发者证书，AppStore 证书，用特定的证书打包你的 IPA，提交到 itunesconnect，审核等等，Xamarin 的教程如下：https://developer.xamarin.com/guides/ios/deployment,_testing,_and_metrics/app_distribution/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:2","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 组件商店的使用 Xamarin 有自己的组件商店，里面有很多免费和收费的组件，刚开始就在这上面找东西，不过网速实在不可恭维，后来发现免费插件这上面有的 GitHub 上几乎都有，所以使用 GitHub 又快又方便。 如果要在组件商店中下载需要注意最后一步需要翻墙，因为网站用了 google 提供的 jquery 库：https://components.xamarin.com/ GitHub 上 Xamarin 提供的一个常用的免费插件目录，这个插件库里有 Xamarin 官方的也有第三方的。我们的项目所使用的插件大多来自这个目录，里面有插件的 NuGet 和 GitHub 地址： https://github.com/xamarin/plugins GitHub 上 Xamarin 官方插件库的源代码：https://github.com/jamesmontemagno/Xamarin.Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"GitHub 上去找东西 在 GitHub 上使用“Xamarin.Forms”为关键词进行搜索，可以快速找到相关资源。 Xamarin-Forms-Labs：这个库很大，包含的东西很多，IOC 容器、序列化组件、缓存组件、UI控件等，我们用得最多的还是 UI 控件。但是用法不是像其他插件一样直接引用它的相关 dll（之前尝试过很久，直接使用会导致莫名其妙的问题），而是直接拷贝代码到我们项目中直接用，但是这个库也正如它的名字一样，是实验性的，在 GitHub 介绍上也可以看到可用控件里几乎所有控件都是 beta 状态，我们在使用过程中也发现了不少 Bug，所以项目里的代码有所改动，跟以前应该不太一样了。我们项目里参考并使用的控件有Checkbox、RadioButton等。 XamarinFormsGestureRecognizers：这个没有使用过，从说明来看是一个手势功能相关的库。 XamarinForms 里的控件默认只有 Tap 点击事件，其他手势操作都在平台内部，这个库就是教你怎样将它们连接起来，然后在 PCL 中写针对控件的手势操作代码。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"IDE技巧 Android 很简单，在 Windows 上启动海马玩模拟器，模拟器启动时间比较长，但启动好之后就可以不用关了，然后只需要用 Visual Studio 设置 Android 项目为启动项，附加到模拟器进行调试即可；真机用 USB 连接使用同样的方式在 IDE 里调试。 iOS 比较麻烦，需要打开 Mac 电脑上的 BuildHost（如果 Mac 不在身边，可使用远程软件 tightvnc 操作，不过一台 Mac 同时只能供一人使用），然后 Visual Studio 设置 iOS 为启动项，可自动寻找局域网内的 Mac 电脑上的 BuildHost，然后输入配对码即可连接成功，如果失败请重启 BuildHost 再试；真机调试一样，不过真机只能连接在 Mac 电脑上。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"一些常用插件 Forms 中插件的使用也比较简单，基本上用一次就会了。首先，插件的使用方式都很统一，Forms 的 PCL 中一般引用两个库,两个库都是 PCL 的，一个带 Abstractions 后缀，里面只定义了接口和实体，不包含逻辑代码；另一个不带 Abstractions 后缀，就像工厂一样，只负责创建 Abstractions 程序集里定义的那些接口的实现者，创建的方式不是使用前面提到的 Xamarin 提供的依赖注入（ UsingDependencyService ），而是条件编译的方式直接 New 对应平台的实现者。在 Andorid 和 iOS（或者 WP）里引用了带 Abstractions 后缀的程序集，然后引用一个真正的属于该平台的程序集（非 PCL，可以调用平台特殊 API），这个程序集实现了 Abstractions 程序集里的接口，它的实例化对象在运行时被真正使用。如果我们自己写插件就可以使用 Xamarin 提供的依赖注入的方式，在特定平台内部写好功能类，然后在 PCL 中直接导出就可以使用了。 然后下面列出一些常用插件： Corcav.Behaviors：帮助你将列表的每一项绑定命令到这个列表的 BindingContext，而不是具体项的 BindingContext，帮助将事件转为命令，Xamarin 自身不带这个功能。 EZ-Compress-for-Xamarin ：压缩图片流的库。 MvvmLight：Mvvm 开发模式的支持库，还用到了里面的 Ioc 容器（SimpleIoc，我们系统里有两套 Ioc 容器，一个就是这个，另一个是 Xamarin 的依赖注入容器）；还用到了它提供的导航组件。 Xam.Plugins.Messaging：提供打电话、发短信、发 Email 等功能。 Media.Plugin：提供拍照、选照片的功能。 PCLStorage ：跨平台的异步 I/O 库。 Vibrate：提供了手机震动的功能。 Toasts.Forms.Plugin ：顶部的那个彩色浮动提示框。 然后一些用得比较多的 UI 组件有：圆形图片、Checkbox、RadioButton、图片选择器等，有自己写的，也有在Xamarin-Forms-Labs的基础上改的。 Andorid 使用插件时注意在工程的 Properties 的 AndroidManifest.xml 中写入对应的权限。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"Xamarin 官方论坛 遇到疑难的问题，上 Xamarin 官方论坛搜索，大部分你遇到的问题上面应该都会有，基本用不着主动提问，这个地址我认为访问频率相当高，地址如下：http://forums.xamarin.com/ ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"没有涉及到的东西 本教程没有涉及到 GIS 相关的内容。 没有对特定平台内部相关知识介绍，我们团队的成员对平台特定API都了解太少，特别是涉及 UI 方面的，要掌握这些知识的难度跟学习原生开发无异，所以对一些难题解决起来比较费力，比如之前的 Android 和 iOS 的 Tab 页样式差异问题（Android 的 Tab 在屏幕上面，iOS 的 Tab 在屏幕底部）。因为 Tab 属于页面，跟控件不一样，不能使用 CustomRenderers 的技术重写样式，在论坛上搜索的结果如下： http://forums.xamarin.com/discussion/54668/bottom-tab-bar-menu-for-android https://forums.xamarin.com/discussion/10004/tabs-on-the-bottom-for-android-example-code http://forums.xamarin.com/discussion/56320/is-there-any-way-to-show-tabs-on-bottom-in-android-using-tabbedpagerenderer 主要意思先是从设计的角度强调不要进行这样通用的设计，如果一定是通用样式那么给出的解决方案也是平台内部的，首先不说技术门槛，这个实现方式跟 Forms 的思想就是有冲突的，所以最好的方案就是在新 APP 里用 Forms 纯手写 Tab 页面。 ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["xamarin"],"content":"资源汇总 官方Demo： https://developer.xamarin.com/samples-all/ https://github.com/xamarin/xamarin-forms-samples 官方程序安装地址： https://static.xamarin.com/installer_assets/v3/Windows/Universal/InstallationManifest.xml https://static.xamarin.com/installer_assets/v3/Mac/Universal/InstallationManifest.xml windows下的ios模拟器 最新的版本信息查询地址： https://developer.xamarin.com/releases/current/ 一个博客提供的最新下载地址： https://www.coderbusy.com/archives/256.html?from=groupmessage\u0026isappinstalled=0 可根据以上版本号手动构造下载地址如下： Win: http://dl.google.com/android/ndk/android-ndk-r10e-windows-x86_64.exe http://dl.google.com/android/installer_r24.4.1-windows.exe http://download.xamarin.com/GTKforWindows/Windows/gtk-sharp-2.12.30.msi https://dl.xamarin.com/XamarinforVisualStudio/Windows/Xamarin.VisualStudio_4.2.1.58.msi http://download.xamarin.com/studio/Windows/XamarinStudio-5.10.3.26-0.msi Mac: http://download.xamarin.com/Installer/MonoForAndroid/jdk-7u71-macosx-x64.dmg http://dl.google.com/android/android-sdk_r24.4.1-macosx.zip http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin http://dl.xamarin.com/MonoFrameworkMDK/Macx86/MonoFramework-MDK-4.6.2.7.macos10.xamarin.universal.pkg https://dl.xamarin.com/MonoDevelop/Mac/XamarinStudio-6.1.2.44.dmg https://dl.xamarin.com/MonoTouch/Mac/xamarin.ios-10.2.1.5.pkg http://dl.xamarin.com/MonoforAndroid/Mac/xamarin.android-7.0.2-37.pkg http://dl.xamarin.com/XamarinforMac/Mac/xamarin.mac-2.10.0.113.pkg 官方文档： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ 官方教材： https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ https://github.com/xamarin/xamarin-forms-book-samples/ 官方论坛： http://forums.xamarin.com/ 常用插件： https://github.com/xamarin/plugins https://github.com/jamesmontemagno/Xamarin.Plugins https://components.xamarin.com/ https://github.com/XLabs/Xamarin-Forms-Labs MvvmCross https://github.com/MvvmCross/MvvmCross https://github.com/MvvmCross/MvvmCross-Plugins ","date":"2016-03-01","objectID":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:0","tags":["dotnet","xamarin"],"title":"Xamarin.Forms 入门学习路线","uri":"/xamarin.forms-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["dotnet"],"content":"Log4net 先说 Log4net，它是.net 平台上一个老牌的日志框架，我接触的时间也不长(因为公司有自己的日志库)，但是看着各开源库都在用这个于是前段时间也尝试去了解了一下。 首先让我认识到 Log4net 强大的地方就是它的多目标输出，可以输出到控制台、文件、数据库、系统事件、Email 等，几乎无所不能。然后它可以通过配置让日志系统实时生效，比如说在服务运行的过程中修改配置改变输出目标，改变日志等级等，均不用重启程序。但是 Log4net 也有一个让我比较头痛的地方就是感觉配置过于复杂，根本记不住，每次都必须去查阅资料，于是乎之前我也针对 Log4net 做了一个简单的封装，内嵌了一个默认使用文件存储的日志配置，提供静态日志方法，还提供一套性能统计的 API(貌似 Visual Studio 2015 后 IDE 已自带了)。以下是这个封装的源代码地址：github，nuget 地址：nuget。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:1:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"NLog 下面说说为什么又关注起 NLog 了，Nlog 没有 Log4net 老牌，使用从 Nuget 下载量来看也没有 Log4net 用户量大，但是它却一直在保持高速的更新状态，从 github 主页上看它所支持的平台也相当广泛，从.net 环境到 mono 再到现在最新的 Xamarin 均支持： nlog支持范围 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:2:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"比较 下面这个是一篇比较这两种日志的文章，应该是翻译的 StackOverFlow 再加上作者自己的一些见解: http://www.cnblogs.com/wanglee/archive/2013/05/22/3092474.html。 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"下面是总结的几点 项目 log4net nlog 流行程度 胜 负 易用性 负 胜 动态配置 平 平 输出目标 平 平 跨平台 负 胜 开源持续维护 负 胜 日志性能 负 胜 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:1","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"性能比较（不再有效，详见文末） 这是用这两款日志框架写的一个性能比较的 Demo，暂时只比较了文件记录日志的情况(因为相对来说这种情况应该是最多的)，附上源码地址。 性能比较结果如图，分别是 Debug 条件编译下的单线程和并行多线程以及独占锁和最小冲突锁的情况： 性能比较结果 ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:3:2","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["dotnet"],"content":"2017 年 9 月 1 日更新 以上性能测试不再有效，根据网友反馈，由于输出内容的略有差异导致上面性能测试出现不公平的情况，log4Net 在输出时可能会有更多的计算量。在优化测试代码情况下，仅让日志框架打印日志内容，其余的包括时间、日志等级、日志类名一律不打印，使用最新版 Dll，两个框架性能相差无几。 推荐阅读： NET 开源项目介绍及资源推荐：http://www.cnblogs.com/Terrylee/archive/2006/12/03/opensource_framework_and_resource_recommendation_Log.html 附加链接： log4net：https://logging.apache.org/log4net/ NLog：https://github.com/NLog/NLog ","date":"2016-01-16","objectID":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/:4:0","tags":["dotnet","log"],"title":"日志框架对比 NLog VS Log4net","uri":"/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94-nlog-vs-log4net/"},{"categories":["xamarin"],"content":"安装 使用标准安装流程(JDK1.6 -\u003e Android SDK -\u003e NDK -\u003e Xamarin Studio -\u003e Xamarin Visual Studio) Android SDK Manager 更改源，可时刻保持最新，一个镜像源地址：mirrors.neusoft.edu.cn；ubuntu.buct.cn；Port: 80，Android SDK的目录结构介绍，Android的一些相关资源 http://ubuntu.buct.edu.cn/android/repository/。 Windows 端破解流程两步：替换 IDE 的 Dll，两个位置，一个是 VS 的 Common 下，一个 Xamarin Studio 的 bin 下；替换对应版本的 mandroid.exe 和 mtouch.exe Mac 端破解流程，Mac 端只负责 iOS 相关的东西，不考虑在 Mac 端开发 Android，首先要安装的东西包括：MonoFramework-MDK-3.12.1.3.macos10.xamarin.x86.pkg； monotouch-8.8.2.4.pkg ；XamarinStudio-5.8.2.7-0.dmg；(版本号注意要匹配，现在这一系列的版本号匹配的是 Windows 端的 3.9.525) 装完之后主要要替换三个东西：/Developer/MonoTouch/usr/bin/mtouch-64； Mtouch-64 替换完毕后需要在终端执行命令：chmod a+x /Developer/MonoTouch/usr/bin/mtouch-64 然后替换/Applications/Xamarin Studio.app/Contents/Resources/lib/monodevelop/AddIns/Xamarin.Ide/Xamarin.Components.Ide.dll 最后替换 /Applications/Xamarin.iOS Build Host.app/Contents/MonoBundle/Xamarin.Components.Ide.dll ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:1:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"模拟器 可以不使用 android 的标准模拟器，使用 Xamarin Android Player，据说性能要好一些，但是版权原因还没测试。 如果使用标准模拟器，可配置硬件加速 首先，你的 CPU 必须支持 Intel 虚拟化技术，如果支持进 BIOS 打开 使用 Android SDK 下载对应的 x86架构的系统镜像 android sdk 上Intel官网下载最新的HAXM虚拟引擎，或者直接用SDK下载 internel haxm 下载后需要手动安装，如果双击安装无效，使用管理员权限运行 CMD，执行安装目录下的那个 Bat 文件；如果提示不支持 Intel 虚拟化技术，但是我们确认是打开了的，可能是因为操作系统装了 Hyper 的原因，卸载 Hyper 重启再试一次 进 AVD 创建基于 X86 的虚拟机 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:2:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓引用的文件结构 android toc 文件夹 作用 Components 登录 Xamarin 账户可下载它官方提供的一些组件直接使用 Assets 存放字体、本地数据库、配置文件等一系列本地资源 Properties 除了常规的程序集版本号等信息，含包括 Android 程序的权限描述文件AndroidManifest.xml Resources 包好 Strings，images，layout 等资源的文件夹，注意程序的视图界面也在该文件夹下，还包括一个 AboutResources.txt 资源描述文件 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:3:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"安卓应用的逻辑结构 安卓应用跟传统应用不一样，没有单点入口，应用和安卓操作系统紧密联系，操作系统可以随时将应用进程载入内存激活应用。因此应用中有一个 Activity 的概念，一个应用由很多 Activity 组成。 android logic struct Activity 的特性： Activity的特性 Label：告诉操作系统这个类属于哪个程序，它会去 AndroidManifest.xml 里去匹配。 MainLauncher：告诉操作系统打开程序后激活哪个页面。 Activity的生命周期：created, started and paused, resumed and destroyed, and so on。 通过重写基类的生命周期方法来实现自己的逻辑，如：OnCreate（应用程序被装载到内存中时调一次），OnResume（设备执行别的任务后，该 Activity 返回设备界面时触发），OnPause（设备将执行其他任务，该 Activity 离开设备界面时触发） 生命周期 生命周期 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:4:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xamarin.Forms相关 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:0","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"简介 可以跨平台的构建用户交互相关的东西，简而言之就是写一套代码三个平台通用，在此基础上也能够结合各平台特有的 Xamarin 本地代码混合一起。 Forms 除了跨平台的好处意外，还支持 Xaml 编写用户界面，不用借助 Goft.Mvvm.light 等第三方框架原生支持数据绑定等。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:1","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"使用前置条件 Android4.0 以上； IOS6.1 以上； 开发环境 VS2013； 解决方案必须是 .Net4.5 以上，PCL 模板，Vs2013update2 可使用 SharedProject。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:2","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"适用程序 适用程序 Xamarin.Forms Xamarin.iOS \u0026 Xamarin.Android 以单纯数据展示为主 程序会用到特殊的交互 快速原型、概念类程序 界面 UI 经过精心设计的程序 只会用到很少的平台特殊功能(API) 会用到很多的平台特殊功能(API) 共享代码比用户UI更加重要 用户UI比共享代码更加重要 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:3","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Xaml相关 Forms 要针对各个平台做界面微调时 OnPlatForm OnPlatForm ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:4","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FormsFQA 第一次运行 Forms 程序会提示“无法链接到远程服务器” Verify the project is selected to be deployed in the Solution Configuration Manager. ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:5","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"Mvvm相关 三套框架：MvvmCross、MvvmLight、XamarinFormsLab http://blog.galasoft.ch/posts/2014/05/mvvm-light-v4-4-with-xamarin-android-support/?utm_source=tuicool MvvmLight For Android要求Android版本在2.3(API10)以上 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:6","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"FQA 一个纠缠很久的问题，Android 设计界面中 Layout 无法加载，报什么网络错误，原因为 Android SDK 升级了最新的 Tools 到 24.3，最新版的 SDK 会引起 Xamarin 出现这个错误，如果使用最新的 Xamarin 则已修复这个错误，如果不想更新 Xamarin 则需要进行 SDK 降级操作 error 限制屏幕旋转功能，指定程序只能使用竖屏或横屏，参考《Xamarin Forms Preview Edition 2》第五章，88(PDF 101)页。 ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:7","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":["xamarin"],"content":"其他资源 安装、破解：http://www.jianshu.com/p/c67c14b3110c ","date":"2016-01-13","objectID":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/:5:8","tags":["dotnet","xamarin"],"title":"Xamarin 入门浅析","uri":"/xamarin-%E5%85%A5%E9%97%A8%E6%B5%85%E6%9E%90/"},{"categories":null,"content":"十四五规划解读 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:0:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"回顾十三五成果 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:1:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"成果 技术创新体系不断完善 数据要素高效汇聚运营 数字基建水平国内领先 数字经济产业蓬勃发展 智慧治理能力稳步提升 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:1:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"问题 数字技术创新引领能力不强 数据要素活力尚未释放 数字基础设施建设仍需加强 数字产业发展质效有待提升 城市智慧应用场景开发不够 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:1:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"十四五发展规划 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:2:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"基本原则 全球视野，创新引领 价值创造，数据赋能 适度超前，基建先行 统筹推进，突出优势 融合带动，应用驱动 开放合作，协同发展 绿色低碳，安全可控 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:2:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"发展目标 数字技术创新策源能力显著增强 全国数据运营枢纽基本建成 数字基础设施体系全面升级 数字产业竞争力不断提升 超大城市数字应用水平全国领先 数字经济开放合作局面全面形成 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:2:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"分区域打造示范场景 中心城区 重点打造智慧旅游示范点，电商交易、智慧物流、智慧港区公共信息服务平台等建设 城市新区 建设量子信息等国家级创新平台，前瞻布局光刻设备、高端软件、XR 扩展现实、隐私计算等领域。构建城市全数据要素流通体系。打造智慧空港、天府国际空港智慧数据中心。在未来医学成建设未来健康社区。龙马湖片区打造智慧园区。 郊区新城 邛崃市数字乡村治理示范县数字乡村试点示范建设，搭建成都市数字农业农村大数据平台，建立国家级农业产业大数据中心。 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:2:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"提升数字技术研发与创新能力 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:3:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"突破关键核心数字技术 攻关数字经济“卡脖子”技术 智能传感器技术攻关 工业软件技术攻关 光刻技术攻关 数字经济重大关键技术攻关 集成电路微纳技术攻关 光电集成技术攻关 网络信息安全技术攻关 人工智能技术攻关 高性能计算技术攻关 区块链技术攻关 数字经济前言引领技术攻关 量子通信技术攻关 功率半导体技术攻关 太赫兹通信技术攻关 脑科学与类脑研究攻关 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:3:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"构建高能级创新平台体系 数字经济战略科技平台 柔性基地微纳结构成像装置 量子信息感存算一体重大科学装置 脑信息与类脑智能研发平台基础设施 数字经济产业创新平台 先进微处理器国家工程研究中心 工业大数据国家工程研究中心 超分辨微纳制造平台 数字文创创新平台 数字经济功能服务平台 天府新区集成电路公共设计平台 集成电量 IP 核平台 国家“芯火”双创基地 国家级工业软件协同攻关和体验推广中心 智能视觉（成都）新一代人工智能开放创新平台 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:3:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"探索重大关键技术攻关新体制 实施关键核心技术攻关“揭榜挂帅”机制 建立关键核心技术攻关组织机制 完善支持重大技术攻关的财政投入机制 优化数字经济科研奖励机制 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:3:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"营造数字技术创新生态 健全科技成果转化体系 探索打造国际化开源社区 加强数字经济领域人才引育 创建数字经济创新发展品牌 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:3:4","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"加快释放数据新要素活力 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:4:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"积极推进数据资源化 聚焦数据资源高效采集 聚焦数据高质量汇聚 聚焦数据资源标准构建 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:4:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"加速推进数据资产化 聚焦公共数据高效运营 聚焦科学数据共建共享 聚焦社会数据融合创新 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:4:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"探索推进数据资本化 探索推进数据证券化 探索建立数据银行 探索创新数据信托产品运营模式 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:4:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"健全数据交易流通机制 数据价值化重点方向 数据资源化 数据资产化 数据资本化 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:4:4","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"适度超前布局新型数字基础设施 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:5:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"全面升级通信网络基础设施 5G 规模化部署工程 物联网应用工程 工业互联网建设工程 星地互联立体网络建设工程 6G、量子通信试验验证工程 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:5:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"前瞻布局先进算力基础设施 精准科学构建算力基础设施架构 高标准运营成都超算中心 加快建设成都智算中心 科学精准谋划云计算数据中心 建立完善边缘算力供给体系 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:5:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"加快建设城市融合基础设施 市政智能感知基础设施 车联网基础设施 智慧机场 能源互联网 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:5:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"加快发展具有竞争优势的数字产业 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:6:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"数字经济核心产业发展重点 集成电路 新型显示 智能终端 软件和信息服务 人工智能 新一代信息网络 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:6:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"聚焦深度融合突出发展数字新兴优势产业 无人机 机器人 智能网联汽车 新型数字化食品 数字医药健康 金融科技 数字文创 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:6:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"聚焦前沿技术前瞻布局数字经济未来赛道 量子科技 光刻设备 6G 通信 脑科学 XR 扩展现实 隐私计算 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:6:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"创新智慧蓉城数字应用场景 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:7:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"建立智慧蓉城运行中心架构 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:7:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"打造“数字政府”智慧治理场景 政务服务“一网通办”场景 城市运行“一网统管”场景 社会诉求“一键回应”场景 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:7:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"营造“数字社会”便民生活场景 智慧医疗场景 智慧教育场景 智慧养老场景 智慧体育场景 智慧人社场景 智慧旅游场景 社区数字消费场景 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:7:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"提升数字经济开放合作水平 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:8:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"推进成德眉资同城化协作 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:8:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"协同共建数字双城经济圈 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:8:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"强化数字经济国内交流合作 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:8:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"扩大数字经济全球开放合作 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:8:4","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"环境影响评价 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:9:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"生态环境影响分析 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:9:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"影响防治措施 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:9:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"生态污染防治方案 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:9:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"保障措施 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:0","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"强化数字经济组织实施 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:1","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"完善数字经济统计监测 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:2","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"加强数字经济资金支持 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:3","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"提升全民数字素养技能 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:4","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"优化数字经济营商环境 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:5","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"保障数字经济数据安全 ","date":"0001-01-01","objectID":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/:10:6","tags":null,"title":"","uri":"/%E5%8D%81%E5%9B%9B%E4%BA%94%E8%A7%84%E5%88%92/"},{"categories":null,"content":"成都建设践行新发展理念的公园城市示范区行动计划（2021—2025年） ","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:0:0","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"市委、市政府印发《成都建设践行新发展理念的公园城市示范区行动计划（2021—2025年）》 市委、市政府印发《成都建设践行新发展理念的公园城市示范区行动计划（2021—2025年）》，并发出通知，要求各地、各部门认真抓好贯彻落实。《成都建设践行新发展理念的公园城市示范区行动计划（2021—2025年）》主要内容如下。 建设践行新发展理念的公园城市示范区，是以习近平同志为核心的党中央赋予成都的重大政治任务和时代使命，是党中央、国务院关于成渝地区双城经济圈建设重大决策部署的重要内容，对探索山水人城和谐相融新实践、超大特大城市转型发展新路径具有重要意义。为深入贯彻《国务院关于同意成都建设践行新发展理念的公园城市示范区的批复》精神，全面落实国家发展改革委、自然资源部、住房和城乡建设部联合印发的《成都建设践行新发展理念的公园城市示范区总体方案》和《中共四川省委、四川省人民政府关于支持成都建设践行新发展理念的公园城市示范区的意见》部署要求，以新发展理念为“魂”、以公园城市为“形”，全面推进公园城市示范区建设，建设创新、开放、绿色、宜居、共享、智慧、善治、安全城市，打造山水人城和谐相融的公园城市，提升现代化国际都市功能能级，发挥极核主干作用，为加快形成带动全国高质量发展的重要增长极和新的动力源提供坚实支撑，制定本计划。 ","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:0","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"一、建设目标 以习近平新时代中国特色社会主义思想为指导，立足新发展阶段，完整、准确、全面贯彻新发展理念，服务和融入新发展格局，坚持以人民为中心，统筹发展和安全，着力厚植绿色生态本底、塑造公园城市优美形态，着力创造宜居美好生活、增进公园城市民生福祉，着力营造宜业优良环境、激发公园城市经济活力，着力健全现代治理体系、增强公园城市治理效能，实现高质量发展、高品质生活、高效能治理相结合，探索山水人城和谐相融新实践和超大特大城市转型发展新路径。 到2025年，公园城市示范区建设取得明显成效。 公园形态与城市空间深度融合，蓝绿空间稳步扩大，城市建成区绿化覆盖率、公园绿化活动场地服务半径覆盖率、地表水达到或好于Ⅲ类水体比例、空气质量优良天数比率稳步提高，生态产品价值实现机制初步建立。居民生活品质显著改善，基本公共服务均等化水平明显提高，养老育幼、教育医疗、文化体育等服务更趋普惠共享，住房保障体系更加完善，覆盖城区的“一刻钟便民生活圈”基本建成，居民收入增长和经济增长基本同步。营商环境优化提升，科技创新能力和产业发展能级大幅提升，绿色产业比重显著提高，西部金融中心功能彰显，国际门户枢纽、国际消费中心等城市功能显著增强。世界文化名城和历史文化名城特征更加彰显，历史文化名镇名村、历史文化街区、历史建筑、历史地段、传统村落得到有效保护，各类文化遗产更好融入城市规划建设。城市治理体系更为健全，城市实现瘦身健体，市政公用设施安全性大幅提升，“智慧蓉城”建设取得明显成效，可持续发展的城市善治和安全保障机制更加完善，超大城市转型发展取得重大进展。 到2035年，公园城市示范区建设目标全面实现。 公园城市形态充分彰显，生态空间与生产生活空间衔接融合，生态产品价值实现机制全面建立，绿色低碳循环的生产生活方式和城市建设运营模式全面形成，现代化城市治理体系更趋成熟，人民普遍享有安居乐业的幸福美好生活，山水人城和谐相融的公园城市全面建成，努力打造中国西部具有全球影响力和美誉度的现代化国际大都市。 ","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:1","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"二、塑造公园城市优美形态，打造城市践行绿水青山就是金山银山理念的示范区 践行绿水青山就是金山银山的理念，把良好生态环境作为最普惠的民生福祉，将好山好水好风光融入城市，坚持生态优先、绿色发展，以水而定、量水而行，深入推进生态环境保护等行动，充分挖掘释放生态产品价值，推动生态优势转化为发展优势，使城市在大自然中有机生长，率先塑造城园相融、蓝绿交织的优美格局。 （一）构建公园形态与城市空间融合格局 强化城市功能导向，以满足公共服务需求为目标统筹基本功能、以服务城市发展战略为指引提升核心功能、以突出区域比较优势为重点培育特色功能，创新城市规划理念，科学编制城市国土空间规划，调整优化生产生活生态空间比例，着力做优做强中心城区、城市新区和郊区新城（卫星城），推动城市发展的均衡性与高质量发展相统一、公共服务供给结构与人口分布相适应、产业能级提升需求与产业空间承载能力相匹配，推动城市内涵发展、区域差异发展、城乡融合发展，促进各区域基本功能就近满足、核心功能互相支撑、特色功能优势彰显，加快形成多中心、网络化、组团式功能结构，实现生产空间集约高效、生活空间宜居适度、生态空间山清水秀。 1．做优做强中心城区 聚焦高端要素运筹、国际交流交往、现代产业支撑、文化传承创新、时尚消费引领等核心功能，推动城市有机更新、产业转型升级、宜居品质提升、治理效能增强，加快实现由中心集聚向辐射带动转变。优化提升锦江区、青羊区、金牛区、武侯区、成华区（以下简称五城区）功能品质，推进瘦身健体、提质增效，大力实施城市有机更新和老旧小区改造，合理降低建设开发强度、人口密度、建筑尺度，有序疏解一般性制造业、传统商品交易市场等非核心功能，加快推进成都太平寺机场、凤凰山机场搬迁，推动增量空间高标准建设；提高产业层次、经济密度，推动现代都市工业向服务型制造、平台化经营、个性化服务转型，提升楼宇工业集聚度和经济产出效益，提质升级研发设计、商务商贸、科创文创、检验检测等生产性服务业；提升城市功能、宜居品质，创新文化旅游和创意业态，建设独具魅力的城市文化地标，建成国际消费中心城市核心承载区，打造更有品质、更具活力、更加繁荣的幸福宜居城区。夯实中心城区其他区域功能承载，着眼实现人口集聚、产业发展和城市品质提升良性互动，完善基础设施、提升公共服务、做强产业支撑，积极联动城市新区推进智能制造提质发展，共建重大功能设施、产业平台，做强国家级经济技术开发区，深化国家“两业”融合发展试点，招引培育“链主”、建圈强链，发展汽车制造、航空装备、轨道交通、电子信息等产业；加快接续五城区势能推动现代服务业提档升级，发挥国家级临空经济示范区、国际铁路港等平台作用，做强临空、临港经济功能，差异化集聚发展现代物流、航空运营、国际贸易等产业；辐射带动郊区新城推动区域协调发展，提升城市服务能力和品质，繁荣发展时尚消费、健康服务、文体休闲等产业，支持人口集聚度较高的区域提升服务品质和智慧安全韧性设施综合配套水平，推动职住平衡、城乡互动、产城融合，提高城市治理现代化水平。实施环城生态公园周边未来公园社区创建行动，充分利用大尺度生态空间牵引城市功能载体建设和内部空间布局优化，推动中心城区居住人口疏解，提升环城生态公园两侧城区宜居宜业品质、功能承载能力。 2．做优做强城市新区 坚持创新驱动、高端引领、产城融合、联动发展，聚焦创新策源转化、国际门户枢纽、新兴产业集聚等核心功能，强化四川天府新区创新驱动高端引领能力，发挥成都高新区、成都东部新区等平台功能牵引作用，优化发展环境、提升产业能级、推动职住平衡、完善配套设施，联动产业优势互补、空间承载能力较大的其他城区，协同发展先进制造业和现代服务业，打造高质量发展的动力引擎和新的增长极。 创新发展四川天府新区。强化科技创新策源和成果转化，提升开放型经济发展水平，加快打造公园城市先行区。推动城园相融先行，构建鹿溪智谷生态绿廊—天府总部商务区、兴隆湖—成都科学城、锦江生态带—华阳生活片区等“三生”融合公园城市组团。打造创新策源功能承载地，在兴隆湖周边区域集中布局重大科技基础设施、科教基础设施、交叉研究平台和科技创新基地，高标准建设天府实验室、西部（成都）科学城，夯实成渝（兴隆湖）综合性科学中心基础。推进创新成果转化和应用示范，发展总部经济，推广“总部+基地”“研发+转化”新型协作模式，大力发展数字经济、高技术服务业、高能级都市工业，联动天府新区邛崃产业园打造新能源、新材料科技成果转化基地，联动中德（蒲江）产业新城打造轨道交通科技成果转化基地，联动新津天府智能制造产业园打造先进智造产业基地。 高质量发展成都高新区。聚焦发展高科技、实现产业化“两轮驱动”，深化国家自主创新示范区建设，打造世界一流高科技园区。围绕电子信息、前沿医学与健康安全，加强下一代通信技术、量子计算、新型疫苗、细胞和基因治疗等关键核心技术攻关。打造高技术产业创新高地，联动郫都区做强集成电路、新型显示，共建电子信息产业核心承载区，打造世界级电子信息产业集群。建设科技金融服务高地，以交子公园金融商务区为主阵地构建科技金融生态，开展数字人民币研究及移动支付创新应用。构建高品质活力区，建设交子公园—交子金融商务区、大源中央公园—大源CBD片区、新川之心公园—成都5G智慧城等新活力社区。 高标准建设成都东部新区。强化临空经济引领带动和先进制造业集中承载，联动简阳市、金堂县一体化发展，提升城市东翼经济与人口承载能力。发挥开放枢纽门户功能，强化天府国际机场航空枢纽优势，建设空港现代物流园、国际航空货运转运（分拨）中心等，增强要素集聚和辐射能力。做强临空经济和先进制造业承载功能，建设成都天府国际机场临空经济区，发展适航产业，引育智能工业、高端装备、新型制造等产业头部企业，引领先进制造业和现代服务业做大做强。健全产业创新功能，聚焦航空航天、电子信息等领域谋划建设未来科技城，推进民航科技创新示范园区建设；以国家医学中心为核心加快建设未来医学城，打造未来医疗技术创新转化园区。构建高品质蓝绿空间网络，联动发展龙马湖—简州新城、绛溪河—空港新城、三岔湖—天府奥体公园组团，引领推动沱江绿色发展经济带建设。 3．做优做强郊区新城（卫星城） 发挥大城市带动大郊区优势，推进以人为核心、以县城和中心镇为重点的新型城镇化，聚焦做优做强生态价值转化、促进乡村全面振兴、公园城市乡村表达等核心功能，因地制宜发展特色经济、补齐基础设施短板、增强公共服务能力，推动建设一批产城融合、职住平衡、交通便利、生态宜居的郊区新城，带动区域组团式发展，拓展超大城市持续健康发展的战略空间。 聚势赋能郊区新城（卫星城）。聚焦不同特色功能，布局建设若干引流聚势、相互赋能、差异发展的郊区新城，进位争先争创全国百强县，加快推动产业转型升级，承接航空枢纽势能外溢拓展新空间，深度挖掘山水和文化资源打造多元特色旅游业态，推动在公园城市乡村表达中红色旅游与生态旅游共同繁荣，推进农业、文旅、商贸融合发展，形成城乡融合发展典范；着眼提高城镇化水平和质量，深化全国县城新型城镇化建设示范，推进补短板强弱项建设，实施高快速路建设和宝成铁路公交化改造等工程，加快打造“半小时”交通圈，推进公共服务设施提标扩面，引进优质教育医疗等公共服务资源，推进市政公用设施提档升级，缩小公共服务在区域和城乡间的差距，以城带乡推动乡村振兴。统筹人口规模、产业形态、交通条件，推动具有一定承载空间、发展潜力的城镇分类建设一批集聚城市功能、优势产业、特色资源的卫星城。 推动镇村提质增效。统筹推进乡村产业、人才、文化、生态、组织振兴，深入推进两项改革“后半篇”文章，编制以片区为单元的乡村国土空间规划，推进城镇与乡村片区开发，规范发展特色镇，推动优化资源配置、提升发展质量、增强服务能力、提高治理效能，培育壮大一批中心镇，夯实郊区新城高质量发展的重要支撑。 （二）建立蓝绿交织公园体系 依托龙门山、龙泉山“两山”和岷江、沱江“两水”生态骨架，推动龙泉山东翼加快发展，完善“一山连两翼”空间总体布局，描绘“绿满蓉城、水润天府”图景，使城市成为“大公园”。 4．构建多层次城市生态绿化体系 加快建立万园相连、布局均衡、功能完善、全龄友好的全域公园体系，统筹建设各类自然公园、郊野公园、城市公园，均衡布局社区公园、“口袋公园”、小微绿地，全面完成“百个公园”建设工程，办好2024年世界园艺博览会。推进多维度全域增绿，深入实施“五绿润城”行动，统筹推进龙泉山城市森林公园、“锦城绿环”“锦江绿轴”等建设，构建与公共服务设施相融的绿道体系，打造涵养城市生态、提升人居环境的绿地系统。推进科学绿化试点，创新以贷款贴息、以奖代补等方式为重点的国土绿化投入机制，支持在环城生态带等开展先行先试。 5．建设城市生态蓝网系统 强化水源涵养、水土保持、河流互济、水系连通，推进供排净治一体化改革，实施都江堰精华灌区续建配套和现代化改造工程，在岷江、沱江等流域开展治污理水护岸筑景行动，推进水资源保护、水环境治理、水生态修复。加强多水源保障供给，推进引大济岷、沱江团结枢纽、三坝水库、久隆水库等重点水源工程建设，加强城市饮用水水源地保护。增强水资源配置能力，推进李家岩水库及配套输水管道、张家岩水库至老鹰水库引水工程，推进“四库”联调工程（久隆水库—石盘水库）等水资源配置项目建设。提升城乡一体供水能力，实施供水管网跨区域连通工程，推进简阳市、彭州市等地区农村供水安全保障工程。强化水生态保护修复，深入实施河（湖）长制，推进沱江、岷江水系综合治理，加强清淤疏浚、自然净化、生态扩容。实施“天府蓝网”行动，推动建设“三级四类”蓝网体系，在主要河流城镇段两侧划定绿化控制带，打造功能复合的亲水滨水空间，建设美丽河湖，避免出","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:2","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"三、增进公园城市民生福祉，打造城市人民宜居的示范区 践行人民城市人民建、人民城市为人民的理念，开展高品质生活城市建设行动，提供优质均衡的公共服务、便捷舒适的生活环境，建设宜居成都，使城市发展更有温度、人民生活更有质感，率先打造人民美好生活的幸福家园。 （九）增强养老托育服务能力 聚焦“一老一小”重点群体，以多元化多层次需求为导向，完善与人口相匹配的养老托育服务，加强特殊人群关爱，建设“全龄共享、友善公益”城市。 22．健全养老服务体系 加快构建政府保障基本、社会增加供给、市场满足需求的养老服务格局。提升养老公共服务保障水平，分区分级规划设置养老服务设施，加强无障碍设施建设与维护，推进公共基础设施适老化改造，到2025年，按标准要求配套建设的养老服务设施实现全覆盖；提高城乡特困老年人集中供养率，探索完善长期照护保障制度，推进高龄津贴提标扩面。创新养老服务供给模式，增强公办养老机构服务能力，扶持发展普惠性民办养老机构；鼓励社会力量建设社区居家养老服务网络，提供日间照料和助餐助洁助行等服务，创新“物业服务+养老服务”“家庭照护床位”等服务模式。开展医养结合能力提升专项行动，鼓励基层医疗卫生机构在社区和养老机构植入服务站点，建设医养康养结合服务设施；鼓励医疗机构设置老年医学科，引导社会资本开办护理院和康复医院，推动培训疗养机构转型发展普惠养老服务，深化全国智慧健康养老应用试点。 23．建设儿童友好城市 建立完善儿童友好的社会政策，引入“1米高度看城市”儿童视角，制定儿童友好城市建设指引，健全残疾儿童教育关爱服务、康复救助制度和困境儿童分类保障制度，完善未成年人保护工作机制。丰富儿童友好的公共服务，大力发展社区婴幼儿照护服务，严格落实城镇小区配套园政策，提高公办幼儿园学位供给能力，建设儿童友好学校、儿童友好医院；丰富儿童文化产品，推动公共文化体育场所向儿童低收费或免费开放；扶持民办幼儿园提供普惠性服务，支持社会力量发展综合托育服务机构和社区托育服务设施，争创全国婴幼儿照护服务示范城市。实施儿童友好城市空间建设行动，加强街区、社区、道路、公共服务设施和场地适儿化改造，推动公共场所建设母婴室、儿童厕所及洗手池、儿童休息和文体活动区，提升社区服务儿童水平。 （十）提供优质医疗教育服务 把人民健康放在优先发展战略地位，落实立德树人根本任务，适应人口空间分布和增长趋势，构建优质高效整合型医疗卫生服务体系和高质量教育体系。 24．实施“健康成都”建设行动 优化医疗资源区域均衡布局，依托四川大学华西医院等医疗资源，建设国家医学中心、国家临床重点专科群；加强公立医院建设，构建市级医院区域急危重症和疑难复杂疾病诊疗服务体系，支持优势医院培育特色专科，扩容提升优质医疗资源，加强市高水平临床重点专科建设，提升专科诊疗、临床医学研究水平和医学人才培养能力。完善分级诊疗和疾病预防控制体系，打造一批县域医疗次中心，实现三级医疗机构区（市）县全覆盖。推进现代医院管理改革，深化城市医疗联合体建设等国家试点，促进医师区域注册和多机构执业。推动中医药传承创新发展，健全中医药服务体系。 25．实施“家门口的好学校”建设行动 强化教育资源科学布局，按照城市功能需要、人口分布形势和增长趋势，加强人口集中流入地学校学位供给，扩大优质教育资源覆盖面，推进中心城区优质教育资源辐射郊区新城（卫星城）。加强素质教育提升发展，统筹全国“双减”试点城市和基础教育综合改革实验区建设。提升公办初中、普通高中办学水平，实施公办初中强校工程，提高市属优质普通高中数量和规模，推动普通高中扩容提质、特色发展，办好一批省级示范性高中、课程特色高中和普职融通综合高中，推进特殊教育优质融合发展。推动高等教育高质量发展，支持在蓉高校“双一流”建设和市属高校跨越式发展，鼓励在蓉职业院校申办本科职业教育。建设优质师资队伍，鼓励高等学校、职业学校与行业企业联合培养“双师型”教师，大力引进高层次教育人才，打造高素质专业化创新型教师队伍。 （十一）完善住房保障体系 坚持房子是用来住的、不是用来炒的定位，建立以政府为主提供基本保障、以市场为主满足多层次需求、以推进职住平衡为基本原则的住房供应体系。 26．健全房地产健康稳定发展机制 完善房地联动和人房地挂钩机制，将城镇新增经营性建设用地中住宅用地占比保持在合理水平，强化住房价格监测和市场调控机制，推进“一城一策”，着力稳地价、稳房价、稳预期。推动完善住房公积金制度。扩大居住小区物业管理覆盖面，提高服务质量和标准化水平。 27．加强舒适可负担住房保障 培育城镇住房租赁市场，扩大租赁住房供给，完善长租房政策，保障承租人及出租人合法权益。健全公租房管理机制，面向城镇住房紧张和低收入住房困难家庭供应，对城镇户籍低保、低收入住房困难家庭依申请应保尽保。扩大保障性租赁住房供给，以建筑面积不超过70平方米的小户型为主，主要利用集体经营性建设用地、企事业单位自有闲置土地、产业园区配套用地和存量闲置房屋建设，单列保障性租赁住房用地集中新建，适当利用新供应国有建设用地建设，主要解决新市民、青年人等群体的住房困难。加强人才安居服务，增加人才公寓供给，建立商品住房配建为主、集中新建为辅的供给模式，完善人才公寓租住购买优惠政策，加强人才集聚区安居保障力度。 （十二）构建立体高效功能复合的交通体系 发挥交通先行支撑引领作用，加快构建与生活消费、产业发展协调互促的通勤体系，推动经济相互融通、要素便捷流动、生活宜居美好。 28．完善互联互通的市域交通网络 构建全域成网的轨道交通体系，完善铁路公交化运营网络，加快干线铁路、城际铁路、市域（郊）铁路、城市轨道融合贯通。推动“轨道+公交+慢行”系统融合发展和高效衔接，推进地铁线路成网增效、轨道公交一体化换乘，优化公交线网及接驳换乘，推动慢行交通系统与公交体系融合衔接。推动城乡路网一体化布局和建设，建成中心城区“环+射”快速路、主干路网体系，联网加密和提档升级农村道路，消除交界地带“断头路”“瓶颈路”。 29．以交通引领带动区域协调发展 推动交通与城市发展和功能布局协同，以交通规划引领融合产业发展、住房建设、基本公共服务等布局，引导人口向城市新区、郊区新城（卫星城）、产业园区等集聚。推进交通与产业发展需求相适，提升交通运输与现代农业、商贸金融、全域旅游等行业需求匹配度，促进资本、人才、数据等要素跨区域高效联通、自由流动。促进公共资源合理配置和职住平衡，以人口分布和市民需求为导向，以地铁站线、公交线网等为重点，布局商业和公共服务设施，构建消费场景、实现便民利民。 30．构建智能高效的交通运行体系 实施智慧交通行动，提升交通运行协调中心（TOCC）系统、智慧交通指挥管理系统功能，推进物联网、智能视觉等融合应用，推进智慧交通基础设施建设，提升智慧管理水平，建设全国智能交通发展高地。实施便捷交通行动，建设城市交通出行即服务（MaaS）一站式出行服务平台，以中德智能网联汽车、车联网四川试验基地等项目建设为牵引，推动车路协同车联网大规模验证与应用，健全特殊人群交通运输服务体系，到2025年，中心城区建成区平均通勤时间下降到35分钟左右。 （十三）建设品质化现代社区 坚持人本化、低碳化、智慧化，绿色生态为基、便捷交通为先、职住平衡为要，统筹规划布局城镇、乡村、产业三类公园社区，发展完整社区，构建幸福美好公园社区体系，梯次建设未来公园社区。以满足社区居民基本生活需求和品质消费需求为目标，品质化推动社区内涵建设，提供养老、托育、医疗、体育、助残等公共服务，推动社区功能完善、业态齐全、居商和谐，让居民生活更加安全、更加便捷、更有温度。 31．打造“一刻钟便民生活圈” 推动社区综合服务设施全覆盖，探索社区综合服务设施“一点多用”，统筹设立幼儿园、托育点、养老服务站、卫生服务中心、体育健身设施、微型消防站、维修点、食堂和公共阅读空间，推动政府服务平台、社区感知设施、家庭终端相连通；因地制宜建设智能快件箱（信包箱），增加停车位和充电桩，推进菜市场标准化改造。开展社区商业发展繁荣行动，发展符合居民家政、休闲、社交、购物等需求的社区商业，引导社区物业延伸发展基础性、嵌入式服务，加快构建“基础便民型+品质提升型”社区商业体系。完善老旧小区及周边水电路气信等配套设施，改善居民基本居住条件。探索社区生活服务“好差评”评价机制和质量认证机制。 （十四）推行绿色低碳生活方式 开展多样化的绿色低碳生活行动，大力引导绿色出行、发展绿色建筑、促进绿色消费等，推进资源全面节约和循环利用，形成简约适度、绿色低碳的生活风尚。 32．实施绿色生活创建行动 构建绿色低碳生活场景，发布低碳生活清单，推广节能低碳节水用品和环保再生产品，减少一次性消费品和包装用材消耗，建立“碳惠天府”等绿色消费激励机制，建设节约型机关、绿色社区、绿色家庭、绿色学校等。推进城市建筑绿色转型，提升建筑绿色标准，推广绿色建材和绿色照明，提高建筑节能运行管理。到2025年，城镇新建建筑全面执行绿色建筑标准。 （十五）加快建设世界文化名城 坚持以社会主义核心价值观为引领，弘扬中华优秀传统文化，用好用活红色文化资源，常态化推动党史学习教育，完善城乡一体、区域均衡的现代公共文化服务体系，营造诗意栖居气息，增强城市文化软实力，争创全国文明典范城市，建设彰显天府文化和蜀风雅韵的世界文化名城。 33．传承创新天府文化 促进优秀传统文化创造性保护、创新性发展，构建天府文化承载体系，挖掘中心城区厚重历史文化资源，保护“两江环抱、三城相重”古城格局，建设东华门、宝墩等十大考古遗址公园；扩大都江堰世界文化遗产和国际旅游品牌影响力，提升文化、旅游带动功能；推进三星堆遗址与金沙遗址联合申报世界","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:3","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"四、激发公园城市经济活力，打造城市人民宜业的示范区 围绕增强城市内生增长动力和可持续发展能力，深入推进宜业环境优化等行动，建设创新成都、开放成都，大力提升高端要素运筹、科技创新策源、高端产业引领、国际门户枢纽等功能，健全绿色低碳循环发展的经济体系，实现壮大优势产业、鼓励创新创业、促进充分就业相统一，提高宜业、宜商、宜游品质，锚定共同富裕方向建设共享成都，使人人都有人生出彩机会。 （十六）深化结构调整推动生产方式绿色低碳转型 锚定实现碳达峰、碳中和目标，全方位优化空间、产业、交通和能源结构，加快形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式。 35．调整优化产业结构 发挥新能源产业国家高技术产业基地优势，围绕强链条、促创新、育生态，建强绿色低碳优势产业集群，探索设立绿色低碳产业基金，加快构建绿色低碳循环经济体系，建设国家绿色产业示范基地。建设光伏高端能源装备引领区，发展光伏高端能源装备产业，构建“光储用”高端产业链，形成上中下游适配协调的产业集群。提升锂电产业发展势能，研发关键材料、锂电池、电池管理与控制系统，做强正负极材料、隔膜、电解液等关键环节，推广动力锂电池和储能锂电池应用。全链条提升新能源汽车产业，推动电池、电机、电控设计生产协同配套，推进汽车产业智能化、网联化发展，打造全国重要的新能源汽车研发制造基地。壮大节能环保产业，加强节能环保设备制造等方面技术研究开发，推进重点行业清洁生产和产业园区循环化改造，开展近零碳排放区试点，建设国家生态工业示范园区。布局新型储能新赛道，依托氢能“制储输用”全产业链优势，发展氢源制备、氢能储运、氢燃料电池，加强氢能全链条安全监管，打造中国“绿氢之都”；探索多元储能新技术路线，积极推进电源、电网、用户侧配套建设储能建设。 36．调整优化交通结构 聚焦以人为本、规划控源、制度激励、智慧赋能，着力构建“轨道引领、公交优先”格局，完善绿色交通基础设施，加快建设绿色低碳交通运输体系。推进公共交通工具和物流配送车辆电动化、新能源化、清洁化，优先推动公交车、出租车、网约车等车辆低碳升级，划设低碳交通示范区，到2025年，中心城区公共交通占机动车出行分担率达60%以上、绿色出行比例达70%以上。强化绿色交通体系基础设施支撑，开展交通基础设施绿色化提升改造，推动居民小区“统建统管”公用和自用充电桩，沿交通通道集约高效布局建设公共充（换）电设施、加氢站，打造成渝“电走廊”“氢走廊”。构建绿色高效的交通运输体系，建设集约化、共享化、智慧化物流节点设施，推动物流园区等铁路专用线建设，推进港作机械、物流枢纽和园区内车辆装备电动化。 37．调整优化能源结构 围绕提升清洁能源供给和安全保障能力，全生命周期提升用能效率，加快建立清洁低碳安全高效的现代能源体系。构建以绿色能源为主体的新型电力系统，推动能源低碳转型，建成大林、成都西、新津500千伏变电站及配套送出等项目，推动川渝1000千伏特高压交流输变电工程和市级骨干电网建设“蓉耀工程”，建设坚强智能电网；建设团结水利枢纽、大邑抽水蓄能电站等重大工程，提升电力系统综合调节能力。提升能源供应安全保障能力，完善油气基础设施体系，勘探开发天府气田、川西气田，推进天然气调峰电站建设，规划建设综合能源站，加快天然气输气干线连环成网。推动能源消费电气化高效化，引导水电、光伏、氢能等非化石能源消费，推行合同能源管理，实施“煤改电”“气改电”行动，开展氢能等清洁能源运营试点，到2025年，非化石能源消费比重提升至50%以上。 （十七）推进活力迸发的创新创业 高水平建设“三区一城”创新发展主引擎，高标准建设成渝（兴隆湖）综合性科学中心，打造具有全国影响力的科技创新中心，推进“科创中国”试点城市建设，形成服务战略大后方建设的创新策源地。 38．构筑科技创新中心策源承载地 依托西部（成都）科学城攻关原创性引领性科技，承载国家战略科技力量布局，编制实施西部（成都）科学城总体规划，做强“一核”创新策源功能、“四区”创新转化能力。高水平建设运营天府实验室，组建运行机构、确定运行机制，实行首席科学家负责制，赋予科研自主权等支持政策。在突出优势领域组建国家实验室以及国家实验室基地。建设中科院成都科研园区。 39．建立开放型创新平台体系 统筹布局国家产业创新中心、工程研究中心、技术创新中心、制造业创新中心和未来产业技术研究院等创新平台，增强技术研发、中试验证、成果转化和应用示范能力。建设国家精准医学产业创新中心、四川省无人机产业创新中心，带动医学科研、生物技术、医疗器械和无人机产业发展。建设同位素及药物国家工程研究中心、绿色工程研究中心。加快推进国家川藏铁路技术创新中心（成都）等建设，实施轨道交通产业高质量发展行动，在优势领域争取获批一批国家技术、制造业创新中心。 40．促进创新创业创造向纵深发展 建设以“双创”示范基地为引领、孵化器加速器等为组成的创新创业载体，鼓励科研院所和高等院校在蓉建立新型研发机构，推进清华四川能源互联网研究院、北航成都创新研究院等建设，打造环高校知识经济圈，构建校院地协同创新平台，促进更多创新成果就地就近产品化、产业化。强化企业创新主体地位，推动科研平台和数据向企业开放，鼓励大企业向中小企业开放资源、场景、需求，鼓励大企业带动更多中小企业融入供应链创新链，梯次培育科技型企业集群。落实企业研发费用加计扣除、增值税留抵退税、首台（套）重大技术装备保险补偿等政策，激励企业创新。 41．建设全国创新人才高地 发挥高品质宜居优势，营造开放包容、人尽其才的良好环境，培养引进用好高水平人才，促进创新型应用型技能型人才成长、集聚、发挥作用。全方位引进和培养高层次急需紧缺人才，实施战略科学家领航、科技领军人才和创新团队集聚、优秀青年科技人才强基、卓越工程师和高技能人才锻造等工程，推行与科技任务、项目招商等相结合的引才模式，推行重大科技攻关首席科学家负责制、重大项目总师负责制。健全以创新能力、质量、实效、贡献为导向的科技人才评价体系，实行“揭榜挂帅”“赛马”等制度，深化赋予科研人员职务科技成果所有权或长期使用权改革，赋予战略科学家、科技领军人才（团队）更大技术路线决定权、更大经费支配权、更大资源调度权。完善外籍人才停居留政策，建立国际职业资格证书认可清单制度。 （十八）“建圈强链”发展彰显竞争力的优势产业 坚持把做实做强做优实体经济作为主攻方向，大力实施重点产业建圈强链行动、重大产业项目攻坚大会战、数字经济赋能行动，打好产业基础高级化和产业链现代化攻坚战，以国家制造业高质量发展示范区为引领，推进制造业强市建设，打响“成都智造”品牌，加快构建竞争优势突出的现代产业体系。 42．实施重点产业建圈强链行动 以先进制造和现代服务业为主攻方向，聚力做强以电子信息、航空航天、轨道交通、汽车、生物医药、绿色食品等为主的先进制造业，做优以物流、研发、设计、商务等为主的现代服务业，增强根植性、核心竞争力和区域带动力。聚焦重点产业“强链”，完善产业链发展规划，绘制重点产业链全景图谱，制定专项产业政策，持续优化产业空间布局，促进“主要承载地+协同发展地”联动发展；发挥链主企业主引擎作用，加强专项培育和服务，鼓励链主企业在蓉设立运营总部、配送结算中心等机构，提升链主企业垂直整合能力，打通重点产业“全链条”。聚焦产业生态“建圈”，围绕做强产业链培育创新链、稳定供应链、配置要素链、提升价值链，聚焦企业全生命周期和多元复合需求匹配资源要素，推动土地高效精准供给，放大重大产业化项目投资基金和科创基金等杠杆撬动作用，争取更多产业基金落户，对产业带动性强的创投基金采取收益让渡等形式给予支持，编制重点产业链“高精尖缺”引才目录，盘活用好标准厂房、专业楼宇、科创空间等产业载体，积极争取符合条件的企业享有西部大开发优惠政策。 43．实施重大产业项目攻坚 紧扣招引储备、落地开工、加快建设和竣工投产环节，大力推进重大产业项目攻坚和招商引智行动。突出产业化龙头项目引领带动，采取“链主企业+公共平台+中介机构+投资基金+领军人才”协同配合招引模式，推进晶圆制造、先进芯片等重大产业项目落地；挖掘龙头企业创新和产业资源禀赋，贯通“小核心、大协作”产业链条；开展重点项目靶向招引，服务国家大型光伏基地项目建设，打造成都造“拳头产品”。突出重大功能性平台项目，促进现代服务业与先进制造业深度融合，加快建设四川区域协同发展总部基地、国家检验检测高技术服务业集聚区等功能平台，引导服务业向专业化和价值链高端延伸，提高制造业高端化、智能化、绿色化发展水平。突出“专精特新”项目营建产业生态，发挥领军企业优势，用好国家超算成都中心等服务平台，推动内部培育和对外招引双向发力，设立新赛道重点企业和重大项目库，打造“单打冠军”、占据市场优势。 44．建设国家数字经济创新发展试验区核心区域 以数据为关键要素，以数字技术与实体经济深度融合为主线，协同推进数字产业化和产业数字化，培育壮大数字经济。实施以“四网融合”为重点的新基建行动，推进国家区块链创新应用综合性试点，建设国家新一代人工智能创新发展试验区、人工智能创新应用先导区。推动数字产业化发展，实施数字技术创新突破工程，围绕“芯屏端软智网”攻坚核心产业，推动大数据产业基础支撑层、数据服务层、融合应用层全产业发展；实施数字经济新业态培育工程，发展基于数字技术的智能经济，突出发展无人机、数字文创等新兴优势产业，前瞻布局量子科技等未来产业。推动产业数字化发展，实施重点行业数字化转型提升工程，开展国家智能制造试点示范，争取国家跨行业跨领域工业互联网平台建设，推进普惠性“上云用数赋智”行动；实施数字化转型支持服务生态培育工程，探索建立数字化转型产","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:4","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"五、增强公园城市治理效能，打造城市治理现代化的示范区 践行一流城市要有一流治理的理念，深入推进治理能力提升等行动，深化重点领域体制机制改革，创新治理理念、治理模式和治理手段，建立系统完备、科学规范、运行有效的城市治理体系，使城市治理更加科学化精细化智能化，全面提升安全韧性水平和抵御冲击能力，加快建成安全成都、善治成都和智慧成都，推动城市治理体系和治理能力现代化，率先探索符合超大特大城市特点和发展规律的治理路径。 （二十四）打造“智慧蓉城” 全面推动城市经济、生活、治理数字化转型，突出应用牵引、数据赋能、安全保障，加快构建数字基础设施体系、城市智慧治理体系和智慧应用场景体系，探索建立“智慧蓉城”标准规范体系，促进政府流程再造、管理模式创新、供给能力提升，建设数字政府和数字社会。 60．建强数字基础设施 构建“主动发现”的智能感知体系，建设城市信息模型（CIM）平台、市域物联感知体系、城市数据资源体系，推进能源、交通运输、市政公用等领域基础设施物联网应用、数字化改造，构建城市数字资源体系，促进行业主管部门间数据共享，提升泛在感知、终端联网、智能调度能力。实施新一代通信网络深度覆盖、高效联通工程，超前部署5G和光纤超宽带“双千兆”网络，前瞻布局6G技术研发，规模部署互联网协议第六版（IPv6），实施智能卫星互联网建设工程。提升云网协同和算网融合水平，抢抓国家实施“东数西算”工程机遇，推动全国一体化算力网络国家枢纽节点建设，推进国家超算成都中心、智算中心等重大项目建设，打造跨网络、跨地域交互的数据中心集群，统一提供超算、智算、通用算法和开发平台服务。 61．优化城市智慧治理体系 做强云网融合、智能敏捷的“城市数据大脑”，建设“数字孪生城市”，搭建“王”字型智慧治理架构，建设市、区（市）县、镇（街道）三级协同联动的“智慧蓉城”运行管理平台，向下延伸至村（社区）、网格形成五级应用，打造线上线下联动、服务管理同步、政府社会协同的指挥应用中枢，增强城市整体运行管理、决策辅助、应急处理能力。建立智慧决策运行机制，深入推进城市体检信息平台建设，构建实时感知、全域覆盖的城市运行生命体征体系，完善跨部门、跨领域数据实时汇聚应用机制，加强数据安全审查和监管配套设施建设，推进城市治理流程再造和管理创新，构建全景呈现态势、精准预警风险、高效处置事件的闭环工作体系，实现城市运行一网统管、政务服务一网通办、公共服务一网通享、社会诉求一键回应。 62．构建智慧应用场景体系 聚焦急时管用、基层爱用、市民受用，创新智慧治理场景，“揭榜攻关”推进公共服务、公共安全、公共管理等应用场景建设，建设疫情防控、交通管理、应急管理、治安管控、生态环保、水务管理等重点领域智慧化平台，加快建设国家智能社会治理实验基地。构筑全民畅享的数字生活，完善“天府蓉易办”平台和“天府市民云”APP功能，发展远程办公、远程医疗、智慧教育、智慧养老、智慧出行、智慧旅游、智慧街区、智慧社区、智慧商圈、智慧楼宇、智慧家居、智慧安防等，提供全方位即时性的线上政务服务和公共服务。 （二十五）增强抵御冲击和安全韧性能力 统筹发展和安全，树牢底线思维，建立城市治理风险清单管理制度，提升风险感知管控、弹性基础设施和应急救援供给能力，创建国家安全发展示范城市。 63．增强重大突发公共卫生事件防控救治能力 统筹决策体系、防控机制和救治能力建设，建立跨部门跨区域指挥体系，构建圈层分区分级处置机制，完善精细化敏捷式管控模式，建设整合集成公安、卫生、通信等信息的智慧防疫平台。实施公共卫生服务能力提升工程，完善公立医院传染病救治设施和疾控中心，推进市公共卫生临床医疗中心三期、紧急医学救援中心等重点项目建设，布局建设高级别生物安全实验室、天府国际健康服务中心，推进二级以上综合医院传染病科室全覆盖。 64．构建灾害监测预警应急救援体系 探索建立自然灾害红线约束机制，围绕地质灾害、环境安全、极端天气等重点领域开展预警水平和应对能力提升工程，实施危化品、燃气、建筑施工、交通运输、地灾防汛、城乡防火等重点领域专项整治，加快建设城市安全风险综合监测预警平台。实施应急救援能力提升行动，建强专业和基层“一主两辅”应急救援队伍，构建跨区域应急管理协作平台，构建极端天气巨灾情景，建成国家西南区域应急救援中心，建强国家危险化学品应急救援成都基地。创新超大城市应急物资保障机制，完善供水、供电、供气、通信等生命线备用设施，推进成都西部粮食和物资战略储备中心、青白江粮食现代物流加工产业园等项目建设，打造综合性国家储备基地，提升应急物资调配能力。 65．建设弹性基础设施网络 增强自然灾害防御能力，开展既有建筑抗震鉴定及加固改造，加强公共建筑消防设施安全保障，推进一类应急避难场所和环城生态区应急避难场所建设；采取搬迁避让和工程治理等手段，防治泥石流和滑坡等地质灾害，阻断和减少城市灾害链式反应。推进内涝治理和海绵城市建设，坚持防御外洪与治理内涝并重，实施岷江、沱江重点河道综合治理工程，建设金堂县西家坝片区防洪排涝设施等项目，优化流域防洪工程布局；新城新区按照国家标准上限要求系统布局建设排水管网，改造四川天府新区污水及雨水干管等管线，实施中心城区排水管网整治工程，提升下穿隧道和下沉式道路排水能力，推进排水管网检测和病害治理，健全源头减排、管网排放、蓄排并举、超标应急的城市排水防涝工程体系。提升市政管网安全性，全面推进老化燃气管道更新改造，加快崇州—彭州等输气管道建设；加快推进供排水等其他老化管道更新改造，推动中心城区“一环九射多片”、四川天府新区“六横五纵”和成都东部新区“三横一纵”等地下综合管廊布局建设。 （二十六）高水平建设平安成都 坚持总体国家安全观，统筹做好政治、经济、社会、文化、网络等安全工作，推动城市治理重心、配套资源向重点领域和基层下沉，提高城市善治水平。 66．完善社会风险全周期防控体系 开展平安城市创建行动，健全决策风险评估、风险预警研判、矛盾协调化解、应急联动处置、全程问责问效的社会风险防控体系，提升反恐处突能力水平，推进市域社会治理现代化试点，创建全国社会治安防控体系建设示范城市。提升经济运行安全保障能力，健全多元化采购和国内供应链衔接备份机制，开展产业竞争力调查和评价，增强产业韧性和抗冲击能力，探索建立受端城市电力、能源、粮食安全保障体系，加强安全生产监管。提升金融风险防控能力，完善金融监管体系，深化金融科技创新监管试点，健全金融风险防控处置、政府债务风险化解机制。 67．建设社会治理共同体 加强镇（街道）、村（社区）党组织对基层各类组织和各项工作的领导，完善各类组织积极协同、群众广泛参与的制度，探索党建引领的城乡社区发展治理与社会综合治理“双线融合”机制，加强楼宇商圈和新业态新就业群体等新兴领域党组织建设。增强镇（街道）行政执行和为民服务能力，有效承接政务服务和公共服务等事项，推进村（居）民委员会规范化建设，加强民生实事民主协商，优化网格化管理服务。完善社会力量参与基层治理激励政策，建立社区与社会组织、社会工作者、社区志愿者、社会慈善资源联动机制，畅通和规范居民诉求表达、利益协调、权益保障通道，建设人人有责、人人尽责、人人享有的社会治理共同体。 （二十七）创新城市内涵式发展方式 积极参与推动全国统一大市场建设，以效率为导向加强土地、劳动力和资本等市场的改革探索，加快技术、数据、资源环境市场培育和规则建设，推动城市发展由外延扩张式向内涵提升式转变。 68．建立集约化的土地利用机制 探索土地管理制度改革，积极争取更大土地配置自主权，控制新增建设用地规模，实行增量安排与消化存量挂钩，严格建设用地标准控制，推动低效用地再开发。推动产业用地高效精准供给，探索创新型产业用地模式，推进“标准地”出让改革，健全长期租赁、先租后让、弹性年期等市场供应体系，提高低效工业用地土地利用率和单位用地面积产出率，建立不同产业用地类型合理转换机制，探索土地复合利用，增加混合产业用地供给。提升存量用地利用效率，探索存量建设用地用途合理转换机制，建设完善城镇建设用地使用权二级市场，鼓励通过市场化方式提高存量用地利用效率。推动建设用地地表、地下、地上分设使用权，探索成片开发区域地下空间整体建设。 69．建立投资收益匹配的投建管运机制 夯实企业投资主体地位，拓宽多元化融资渠道，促进民间投资，鼓励银行业金融机构按市场化原则增加中长期贷款投放。发挥政府投资引导作用，推动政府投资等资金重点投向市政公用、公共服务、环境治理、产业配套等公共领域项目，发行地方政府专项债券支持符合条件的公益性城镇基础设施建设项目，优化预算管理制度，有效防控地方政府债务风险。创新城市投资运营模式，按照站城一体、功能复合、综合运营原则，全域推行以公共交通为导向的开发（TOD）模式，加强片区综合开发，提高收支平衡水平，促进土地增值收益更多用于民生福祉。盘活存量优质资产，稳妥推进基础设施领域不动产投资信托基金（REITs）试点。提升国有企业服务城市发展功能，争取区域性国资国企综合改革试验，深化混合所有制改革，开展以效率为导向的国资经营评价，提高国有企业服务城市战略、民生保障、参与竞争能力，以市场化机制加大国有企业在战略产业等关键领域布局。 ","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:5","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"},{"categories":null,"content":"六、实施保障 （二十八）加强组织保障 坚持和加强党的全面领导，深刻领悟“两个确立”的决定性意义，增强“四个意识”、坚定“四个自信”、做到“两个维护”，把党的领导贯穿公园城市示范区建设全过程、各领域、各环节。充分发挥党总揽全局、协调各方的领导核心作用，发挥各级党组织作用，为公园城市示范区建设提供根本保证。推动全面从严治党向纵深发展，营造风清气正的良好政治生态。加强干部队伍建设，完善干部培训、考核、激励等机制，大力选拔在公园城市示范区建设工作中政治坚定、善于统筹、敢闯敢试、担当作为的干部，以正确用人导向引领干事创业导向，激励党员干部担当作为。 （二十九）深化改革创新 用好国家赋予的先行先试和改革授权，加强与对口国家部委、省级部门的沟通协调，在公园城市建设、生态产品价值实现、城乡融合发展、科技创新、片区综合开发、经济区与行政区适度分离改革、要素市场化配置综合改革等领域，全方位加快探索创新。开展公园城市示范区先行点位建设活动，按规定组织评选表彰建设践行新发展理念的公园城市示范区先进集体和先进个人。及时总结上报改革经验成果，适时开展公园城市示范区建设中期评估，优化提升政策举措。深化公园城市理论研究，探索构建公园城市的规划、指标、指数、政策、评价等体系，加快制定地方性法规。 （三十）完善工作机制 市建设践行新发展理念的公园城市示范区领导小组要充分发挥牵头抓总、把关统筹作用，研究部署协调重大事项、重大问题。领导小组办公室设在市发改委，实体化运行，统筹协调市公园城市局、市规划和自然资源局、市住建局等职能部门，将公园城市示范区建设纳入市委、市政府“每月调度”工作，构建分工对上沟通、要素政策保障、关键信息互通、重大事项共商、领导牵头攻坚、跟踪督办问效等工作机制，形成工作闭环，合力推进各项建设。各级各部门要对照本计划制定具体举措，严格落实责任，创造性开展工作。要全方位、多角度、深层次开展宣传活动，常态发布公园城市示范区建设城市机会清单，动员社会各方力量参与，汇聚共建公园城市示范区强大合力。本计划贯彻落实情况纳入领导干部政绩考核和党政机关绩效考核事项。重大事项及时向省委、省政府请示报告，加强向国务院有关部门汇报沟通。 ","date":"0001-01-01","objectID":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/:1:6","tags":null,"title":"","uri":"/%E6%88%90%E9%83%BD%E5%BB%BA%E8%AE%BE%E8%B7%B5%E8%A1%8C%E6%96%B0%E5%8F%91%E5%B1%95%E7%90%86%E5%BF%B5%E7%9A%84%E5%85%AC%E5%9B%AD%E5%9F%8E%E5%B8%82%E7%A4%BA%E8%8C%83%E5%8C%BA%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%9220212025%E5%B9%B4/"}]